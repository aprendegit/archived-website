<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	
	xmlns:georss="http://www.georss.org/georss"
	xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#"
	>

<channel>
	<title>Aprende GIT</title>
	<atom:link href="https://aprendegit.com/feed/" rel="self" type="application/rss+xml" />
	<link>https://aprendegit.com/</link>
	<description>Información y experiencias sobre el uso de git</description>
	<lastBuildDate>Thu, 25 Jul 2024 14:51:36 +0000</lastBuildDate>
	<language>es</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=6.6.1</generator>
<site xmlns="com-wordpress:feed-additions:1">43885904</site>	<item>
		<title>Usando Git con git-flow</title>
		<link>https://aprendegit.com/git-con-git-flow/</link>
					<comments>https://aprendegit.com/git-con-git-flow/#comments</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Wed, 10 Dec 2014 10:24:08 +0000</pubDate>
				<category><![CDATA[Eventos / charlas / conferencias]]></category>
		<category><![CDATA[workflow]]></category>
		<guid isPermaLink="false">https://aprendegit.com/?p=704</guid>

					<description><![CDATA[Ayer tuvimos una nueva reunión del grupo de usuarios de git (la última de este 2014 que se acaba). En esta ocasión Oscar Vítores compartió con nosotros su experiencia en el uso de git-flow. La presentación&#160;fue muy interesante ya que no sólo se limitó a exponer qué es y cómo funciona, sino que nos contó [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>Ayer tuvimos una nueva reunión del <a title="Grupo de usuarios de git" href="http://www.meetup.com/Spanish-Git-Meetup/" target="_blank" rel="noopener">grupo de usuarios de git</a> (la última de este 2014 que se acaba).</p>
<p>En esta ocasión <a title="Oscar Vítores en twitter" href="https://twitter.com/oxkhar" target="_blank" rel="noopener">Oscar Vítores</a> compartió con nosotros su experiencia en el uso de git-flow. La presentación&nbsp;fue muy interesante ya que no sólo se limitó a exponer qué es y cómo funciona, sino que nos contó cómo la&nbsp;usa con su equipo, qué le sirvió y cuándo git-flow empezó a quedarse corto.</p>
<p>El meetup estuvo muy bien, con muchas&nbsp;preguntas y comentarios durante la exposición. Gracias a todos los que estuvisteis allí y a Oscar por venir a contarnoslo en persona.</p>
<p>Aquí tenéis la grabación que hicimos a través de&nbsp;hangout (<a href="http://slides.oxkhar.com/gitflow">y aquí las diapositivas</a>):</p>
<p><iframe src="//www.youtube.com/embed/b7tp-gx9gIs" width="560" height="315" frameborder="0" allowfullscreen="allowfullscreen"></iframe></p>
<p>Una agradecimiento desde la organización de los meetups al <a title="Espacio de coworking Kunlabori" href="http://kunlabori.es/" target="_blank" rel="noopener">espacio de coworking Kunlabori</a> por cedernos la sala, micro y conexión para reunirnos y hacer la grabación.</p>
<p>Otros enlaces:</p>
<ul>
<li>Serie de <a title="¿Qué es git-flow?" href="https://aprendegit.com/que-es-git-flow/">artículos sobre git-flow</a> en aprendegit.com</li>
<li><a href="https://www.youtube.com/playlist?list=PL7RY1oVPX-_W1u964phYowAFnbhbAOsWI">Taller de git-flow</a> en la Drupalcamp de 2013</li>
</ul>
]]></content:encoded>
					
					<wfw:commentRss>https://aprendegit.com/git-con-git-flow/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
		<post-id xmlns="com-wordpress:feed-additions:1">704</post-id>	</item>
		<item>
		<title>git no borra nada&#8230; hasta que pasa el recolector de basura</title>
		<link>https://aprendegit.com/ggit-borra-nada-hasta-que-pasa-el-recolector-de-basura/</link>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 01 Aug 2014 06:35:38 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<guid isPermaLink="false">https://aprendegit.com/?p=688</guid>

					<description><![CDATA[La semana pasada (el 21 de julio para ser más concretos) tuvo lugar el tercer meetup del grupo de usuarios de git. En esta reunión estuvimos hablando de una característica muy importante y poco conocida de git: git no borra commits. Cuando hacemos ciertas operaciones, como un commit &#8211;amend, rebase o resets, parece que los commits [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>La semana pasada (el 21 de julio para ser más concretos) tuvo lugar el <a href="http://www.meetup.com/Spanish-Git-Meetup/events/193657692/">tercer meetup</a> del <a href="http://www.meetup.com/Spanish-Git-Meetup/">grupo de usuarios de git</a>.</p>
<p>En esta reunión estuvimos hablando de una característica muy importante y poco conocida de git: git no borra commits. Cuando hacemos ciertas operaciones, como un commit &#8211;amend, rebase o resets, parece que los commits se modifican o desaparecen. Sin embargo, lo cierto es que git no los borra, ni los modifica: siempre crea commits nuevos a partir de los anteriores.</p>
<p>Y si no los borra ¿por qué no los veo? ¿dónde están los commits originales? ¿cómo los puedo recuperar? y por último ¿cómo los borro definitivamente si es lo que realmente quiero hacer?. A estas y otras preguntas dimos respuesta en esta reunión.</p>
<p>Nos veremos de nuevo ya en septiembre ¡que paséis todos un buen verano!</p>
<h2>Parte I: git no borra nada&#8230;</h2>
<p>En esta primera parte de la charla, vemos una característica muy poco conocida de git: git mantiene los commits que parece que se han borrado y aunque no los veamos, siguen estando en nuestro repositorio (en la carpeta .git).</p>
<p>Para mostrarlo, comenzamos viendo cómo la opción &#8211;amend del comando git-commit no «modifica» el último commit sino que crea uno nuevo. Después pasamos a demostrar este comportamiento «rompiendo» un repositorio: ejecutamos una serie de operaciones (rebases y resets) hasta «perder» casi todos los commits y posteriormente utilizamos SmartGit y el reflog para «ver» esos commits que parece que se han perdido y devolver el repositorio a su estado inicial.</p>
<p><iframe src="//www.youtube.com/embed/oIDyQ1fOeS4" width="853" height="480" frameborder="0" allowfullscreen="allowfullscreen"></iframe></p>
<p>&nbsp;</p>
<h2>Parte II: &#8230;hasta que pasa el recolector de basura</h2>
<p>En esta segunda parte de la charla, vemos cuáles son las condiciones que se deben cumplir para que los commits desaparezcan de y se borren definitivamente del repositorio. Analizamos el comportamiento del comando git-gc, aprendemos a caducar entradas del reflog para poder «limpiar» y finalmente borramos los commits del disco duro.</p>
<p>Al final de la presentación, hablamos del comando git-fsck y mostramos cómo funciona y qué información nos puede dar.</p>
<p><iframe src="//www.youtube.com/embed/qwL3lhRwn78" width="853" height="480" frameborder="0" allowfullscreen="allowfullscreen"></iframe></p>
]]></content:encoded>
					
		
		
		<post-id xmlns="com-wordpress:feed-additions:1">688</post-id>	</item>
		<item>
		<title>Primera reunión del grupo de usuarios de git</title>
		<link>https://aprendegit.com/primera-reunion-del-grupo-de-usuarios-de-git/</link>
					<comments>https://aprendegit.com/primera-reunion-del-grupo-de-usuarios-de-git/#comments</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Wed, 11 Jun 2014 13:17:35 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<guid isPermaLink="false">https://aprendegit.com/?p=678</guid>

					<description><![CDATA[Después de unos cuantos meses un poco «inactivos» hemos retomado la actividad con fuerza. Hace casi un mes (el 13 de mayo) abrimos el Grupo de usuarios de git en meetup.com contando con Israel Alcazar, uno de los pesos pesados de git,  como coorganizador. En este tiempo se han unido al grupo más de 150 personas y ayer tuvimos la primera [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>Después de unos cuantos meses un poco «inactivos» hemos retomado la actividad con fuerza. Hace casi un mes (el 13 de mayo) abrimos el <a href="http://www.meetup.com/Spanish-Git-Meetup/">Grupo de usuarios de git</a> en meetup.com contando con Israel Alcazar, uno de los pesos pesados de git,  como coorganizador. En este tiempo se han unido al grupo más de 150 personas y ayer tuvimos <a href="http://www.meetup.com/Spanish-Git-Meetup/events/183012642/">la primera reunión</a> en el Hogar Extremeño de Madrid.</p>
<p>Es un sitio atípico, con mucha historia detrás. Situado en el número 59 de la Gran Vía, el Hogar Extremeño se diseñó sobre plano a la vez que se hizo el edificio a finales de los 50. Lo mejor de todo no es lo bien comunicado que está, es que tenemos una barra con cervezas en el mismo salón en el que hacemos las charlas.</p>
<p>Aparte de git, dedico una buena parte de mi tiempo (la mayoría) al proyecto extremadura.com. Dentro de este proyecto tenemos un «subproyecto» podemos decir que se llama «Extremadura en el mundo» y que tiene como objetivo poner en valor todo lo que tenga que ver con Extremadura fuera de Extremadura. Estamos convencidos de que tradición y tecnología no son incompatibles y la mejor forma de demostrarlo es tener un meetup de git en un lugar tradicionalmente considerado como «para jugar a las cartas y al dominó». Fue muy divertido ver las caras de la gente cuando entraban allí como despistadillos, menos mal que avisamos que era un sitio atípico.</p>
<p>Desde la organización, queremos agradecer de manera especial al Hogar Extremeño y a todas las personas que hicieron que ayer nos sintiésemos como en casa (o incluso mejor).</p>
<p>Y ya sin más, os dejo las grabaciones de las dos intervenciones de ayer. Nos vemos en la siguiente.</p>
<p><iframe loading="lazy" src="//www.youtube.com/embed/W0goZDxQ8EA" width="853" height="480" frameborder="0" allowfullscreen="allowfullscreen"></iframe><br />
<iframe loading="lazy" src="//www.youtube.com/embed/8WBJ7Ehr3-U" width="853" height="480" frameborder="0" allowfullscreen="allowfullscreen"></iframe></p>
]]></content:encoded>
					
					<wfw:commentRss>https://aprendegit.com/primera-reunion-del-grupo-de-usuarios-de-git/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
		<post-id xmlns="com-wordpress:feed-additions:1">678</post-id>	</item>
		<item>
		<title>Añadiendo un remoto a un proyecto en XCode5</title>
		<link>https://aprendegit.com/anadiendo-un-remoto-a-un-proyecto-en-xcode5/</link>
					<comments>https://aprendegit.com/anadiendo-un-remoto-a-un-proyecto-en-xcode5/#comments</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 04 Oct 2013 07:34:17 +0000</pubDate>
				<category><![CDATA[XCode]]></category>
		<guid isPermaLink="false">https://aprendegit.com/?p=659</guid>

					<description><![CDATA[En uno de los comentarios de la al post sobre las novedades de XCode 5, nos comentaba un lector que estaba teniendo algún problema para añadir un repositorio remoto a un proyecto en XCode 5. A continuación os indico cómo hacerlo usando la interfaz gráfica. Para ello, necesitamos lo siguiente: Un proyecto XCode 5 que [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>En uno de los comentarios de la <a title="Repaso rápido a las novedades de git en XCode 5" href="https://aprendegit.com/repaso-rapido-a-las-novedades-de-git-en-xcode-5/">al post sobre las novedades de XCode 5</a>, nos comentaba un lector que estaba teniendo algún problema para añadir un repositorio remoto a un proyecto en XCode 5. A continuación os indico cómo hacerlo usando la interfaz gráfica. Para ello, necesitamos lo siguiente:</p>
<ul>
<li><span style="line-height: 14px;">Un proyecto XCode 5 que ya está bajo git.</span></li>
<li>La URL de un repositorio remoto, ya sea en BItbucket, Github, gitolite o el que sea en vuestro caso</li>
</ul>
<h1>Añadiendo un repositorio remoto git en Xcode 5</h1>
<p>Desplegamos el menú «Source Control» dentro de XCode en nuestro proyecto. Dentro de este menú, en la sección «Working Copies», seleccionáis la única que inicialmente tendréis y que contiene el nombre del proyecto y la rama (normalmente master). En el submenú que se despliega, debéis seleccionar la última opción, que se llama «Configure [nombre del proyecto]».</p>
<p><a href="https://aprendegit.com/wp-content/uploads/2013/10/Voila_Capture294.png"><img loading="lazy" decoding="async" class="aligncenter size-full wp-image-660" alt="Menú &quot;Source Control&quot; desplegado" src="https://aprendegit.com/wp-content/uploads/2013/10/Voila_Capture294.png" width="576" height="318" srcset="https://aprendegit.com/wp-content/uploads/2013/10/Voila_Capture294.png 576w, https://aprendegit.com/wp-content/uploads/2013/10/Voila_Capture294-300x165.png 300w" sizes="(max-width: 576px) 100vw, 576px" /></a>Al hacer esto, nos aparecerá una ventana emergente con tres pestañas. Seleccionamos la pestaña «remotes» que mostrará un listado vacío. En la parte inferior derecha, hacemos clic sobre el icono «+» y se desplegará un menú con dos opciones:</p>
<ul>
<li><span style="line-height: 14px;">Add remote</span></li>
<li>Create new remote</li>
</ul>
<p>Seleccionamos la primera opción: «Add remote»</p>
<p><a href="https://aprendegit.com/wp-content/uploads/2013/10/Voila_Capture297.png"><img loading="lazy" decoding="async" class="aligncenter size-full wp-image-661" alt="menú re repositorios remotos" src="https://aprendegit.com/wp-content/uploads/2013/10/Voila_Capture297.png" width="691" height="478" srcset="https://aprendegit.com/wp-content/uploads/2013/10/Voila_Capture297.png 691w, https://aprendegit.com/wp-content/uploads/2013/10/Voila_Capture297-300x207.png 300w, https://aprendegit.com/wp-content/uploads/2013/10/Voila_Capture297-624x431.png 624w" sizes="(max-width: 691px) 100vw, 691px" /></a>En la siguiente ventana emergente que nos aparecerá, añadimos el nombre del repositorio remoto en el campo «Name» y la URL del repositorio en el campo «Address»</p>
<p><a href="https://aprendegit.com/wp-content/uploads/2013/10/Voila_Capture300.png"><img loading="lazy" decoding="async" class="aligncenter size-full wp-image-662" alt="Selección de nombre del remoto y URL" src="https://aprendegit.com/wp-content/uploads/2013/10/Voila_Capture300.png" width="479" height="145" srcset="https://aprendegit.com/wp-content/uploads/2013/10/Voila_Capture300.png 479w, https://aprendegit.com/wp-content/uploads/2013/10/Voila_Capture300-300x90.png 300w" sizes="(max-width: 479px) 100vw, 479px" /></a>Presionáis en «Add Remote» y listo, ya tenéis el repositorio remoto configurado.</p>
<p>Para terminar, desplegáis el menú «Source Control», y seleccionáis push. En la ventana emergente seleccionáis el repositorio remoto que acabáis de crear, pulsáis el botón «Push» y ya tenéis el repositorio en vuestro remoto.</p>
<h2>«Create New Remote»</h2>
<p>En el menú de creación del repositorio remoto, hay una opción adicional «Create new remote» que está relacionada con las nuevas funcionalidades que nos traerá Mavericks y de la que hablaremos en un futuro.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://aprendegit.com/anadiendo-un-remoto-a-un-proyecto-en-xcode5/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
		<post-id xmlns="com-wordpress:feed-additions:1">659</post-id>	</item>
		<item>
		<title>Repaso rápido a las novedades de git en XCode 5</title>
		<link>https://aprendegit.com/repaso-rapido-a-las-novedades-de-git-en-xcode-5/</link>
					<comments>https://aprendegit.com/repaso-rapido-a-las-novedades-de-git-en-xcode-5/#comments</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Wed, 25 Sep 2013 21:35:06 +0000</pubDate>
				<category><![CDATA[XCode]]></category>
		<guid isPermaLink="false">https://aprendegit.com/?p=647</guid>

					<description><![CDATA[Hace ya una semana que la nueva versión de XCode, la versión 5, está disponible públicamente en la Mac App Store. En la presentación de la NSSpain de Logroño la semana pasada comenté que el soporte para git dentro de XCode ha mejorado en esta nueva versión aunque no pude entrar en detalles (cosas del [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>Hace ya una semana que la nueva versión de XCode, la versión 5, está disponible públicamente en la Mac App Store. En <a href="http://www.slideshare.net/aprendegit/nsspain2013">la presentación</a> de la <a href="http://nsspain.com/">NSSpain de Logroño</a> la semana pasada comenté que el soporte para git dentro de XCode ha mejorado en esta nueva versión aunque no pude entrar en detalles (cosas del NDA). Voy a empezar a destripar cuáles son las novedades que tenemos a nuestra disposición.</p>
<h2>La cosa ha mejorado pero&#8230;</h2>
<p>La verdad es que no es para echar cohetes. El cliente git sigue estando a años luz de otros IDEs que lo tienen integrado como Eclipse, Netbeams o los productos de <a href="http://www.jetbrains.com/">jetbrains</a>. Y si lo comparamos con <a href="http://www.sourcetreeapp.com/">SourceTree</a>, <a href="http://www.git-tower.com/">Git Tower</a> o <a href="http://www.syntevo.com/smartgithg/">Smart Git</a> te das cuenta de que los ingenieros de Apple todavía tienen mucho trabajo por hacer.</p>
<p>Ahora bien, con las novedades que hay disponibles lo cierto es que hay algunas tareas más o menos recurrentes que ahora sí podemos hacer desde XCode, ahorrándonos unos cuantos cambios de pantalla al día.</p>
<h2>Hacer commits desde XCode</h2>
<p>Esta es una opción que ya estaba disponible en las versiones anteriores. Basta pulsar CMD-ALT-C para que se abra la interfaz, escribamos el mensaje y hagamos el commit. Esta pantalla no ha cambiado prácticamente nada con respecto a la versión 4.</p>
<h2>Operaciones más habituales</h2>
<p><span style="line-height: 1.714285714; font-size: 1rem;">Una de las características que tiene que tener cualquier SCM es la de «desaparecer», es decir, no darte cuenta de que lo estás usando. Las operaciones que hagas con él deben de ser rápidas y ágiles. Pues bien, XCode 4 estaba diseñado justo para lo contrario: </span>para crear una rama era necesario abrir el organizador. El proceso era lento y suponía tener que cambiar de ventana, buscar un botón por ahí escondido, crear la rama, cambiarnos a ella y volver a la ventana del proyecto.</p>
<p>Aquí hay una sustancial mejoría. Ahora disponemos de un menú en la parte superior desde el que podemos hacer las operaciones más comunes: crear ramas, cambiarnos de rama, hacer push y hacer pull, deshacer cambios, resolver conflictos e incluso gestionar los remotos.<a href="https://aprendegit.com/wp-content/uploads/2013/09/Voila_Capture288.png"><img loading="lazy" decoding="async" class="aligncenter size-full wp-image-648" alt="Nuevo menú SCM en XCode5" src="https://aprendegit.com/wp-content/uploads/2013/09/Voila_Capture288.png" width="307" height="318" srcset="https://aprendegit.com/wp-content/uploads/2013/09/Voila_Capture288.png 307w, https://aprendegit.com/wp-content/uploads/2013/09/Voila_Capture288-289x300.png 289w" sizes="(max-width: 307px) 100vw, 307px" /></a></p>
<p>Estas son las tareas más comunes así que cuando estamos trabajando nosotros solos o tenemos un flujo de trabajo muy simple, este menú nos puede ahorrar el tener que estar cambiando de aplicación para hacer cosas sencillas.</p>
<h2>Gestión de repositorios remotos</h2>
<p>La gestión de repositorios remotos del proyecto es ahora mucho más cómoda. En las pruebas que he realizado, he podido añadir el repositorio remoto de bitbucket y ha cogido mi clave SSH sin tener que hacer nada. En cuestión de un minuto tenía el remoto configurado y haciendo push/pull. En una entrada posterior veremos cómo hacerlo.</p>
<h2>Mejoras sustanciales en la estructura de los ficheros XML</h2>
<p>Esta es posiblemente la parte que más expectación ha despertado en los últimos meses desde que las versiones para desarrolladores han estado disponibles: ¡ahora se pueden hacer merges de los Story Boards!</p>
<p>Las mejoras más evidentes son:</p>
<ul>
<li><span style="line-height: 1.714285714; font-size: 1rem;">Si ahora abres el story board o el fichero xib </span><strong><span style="line-height: 1.714285714; font-size: 1rem;">y no tocas nada</span></strong><span style="line-height: 1.714285714; font-size: 1rem;">, el fichero no aparece como modificado (lo que significa que no da conflictos).</span></li>
<li><span style="line-height: 1.714285714; font-size: 1rem;">Por otro lado, el formado de los ficheros ha cambiado y el XML, aunque sigue teniendo su miga, es más legible.</span></li>
<li>Este formato permite resolver conflictos en los XIB/Story Boards con mucha más facilidad, incluso de forma automática en algunos casos. En una primera prueba muy sencilla en la que creé dos botones en el mismo lugar en dos ramas diferentes dentro de un fichero .xib, pude resolver el conflicto muy fácilmente copiando un trozo del XML.</li>
</ul>
<p>Aunque hay mejoras en este sentido, yo sigo siendo muy escéptico  En una prueba más elaborada en la que modifiqué un story board en dos ramas diferentes, la resolución del conflicto no era ya tan evidente y el XML no estaba tan claro. Me imagino que con un poco de práctica y experiencia será más fácil resolver los conflictos. Os iré contando cómo evoluciono según vaya usando más la herramienta.</p>
<h2>¡El commit inicial incluye la configuración del IDE (xcuserdata)!</h2>
<p>En XCode 4, cuando creabas un proyecto, había algunos ficheros que XCode no añadía al repositorio, en particular las carpetas xcuserdata. Pues bien, eso ya no es así y cuando creas un proyecto y marcas la casilla para que se cree el repositorio, XCode añade al repositorio todos los ficheros, incluido las carpetas xcuserdata.</p>
<p>A mi personalmente no me gusta tener esta información en el repositorio. Es cierto que existen algunos casos en los que puede ser útil: si queréis que todo el mundo comparta la configuración del IDE o para compartir breakpoints entre los miembros de un equipo. Mi experiencia es que en general, suele ser una fuente de conflictos que me quitan mucho tiempo y por eso ignoro estas carpetas en el .gitignore.</p>
<h2>La que se lleva la palma&#8230;</h2>
<p>La funcionalidad que más me gusta de todas las novedades que incluye XCode 5 en cuanto a la gestión de código fuente se refiere es&#8230;<strong>¡¡Poder desactivarla!!</strong></p>
<p>Si abris las preferencias y vais a «Source Control», podéis desactivar el soporte SCM. Si lo hacéis, lo único que ocurre es que XCode ignora el repositorio git del proyecto, las opciones del menú «Source Control» aparecen desactivadas y el soporte para git deja de funcionar. El repositorio git queda intacto, así que podéis seguir usando la línea de comandos o vuestro cliente favorito para seguir gestionando el código fuente fuera de XCode.</p>
<p>Si después queréis activarlo, deshacéis los pasos y listo; eso sí, tuve que cerrar el proyecto y volverlo a abrir para que la interfaz volviera a mostrar los ficheros modificados y añadidos.</p>
<p style="text-align: center;"><a href="https://aprendegit.com/wp-content/uploads/2013/09/Voila_Capture289.png"><img loading="lazy" decoding="async" alt="Voila_Capture289" src="https://aprendegit.com/wp-content/uploads/2013/09/Voila_Capture289.png" width="244" height="282" /></a></p>
<h2></h2>
<h2>Lo que sigo echando en falta</h2>
<p>Aunque la cosa ha mejorado mucho, todavía echo en falta algunas cosas:</p>
<ul>
<li><span style="line-height: 14px;">No entiendo la obsesión por ocultar el grafo. El grafo es ese típico dibujito lleno de pelotas, líneas y etiquetas que al principio no se entiende bien. Una vez sabes cómo funciona, cuesta trabajar en un repositorio sin él y en XCode no está.</span></li>
<li>Stashing</li>
<li>Rebasing</li>
<li>Poder hacer commits de parte de un fichero (interactive staging)</li>
<li>Más documentación acerca del formato XML de los xib y story boards (si alguien sabe dónde está que por favor nos lo diga). Eso nos permitiría resolver los conflictos más fácilmente.</li>
<li>Poder trabajar con flujos de trabajo un poco más elaborados. Si habéis trabajado o estáis trabajando con git-flow, vais a necesitar línea de comandos o Sourcetree necesariamente.<a href="https://aprendegit.com/wp-content/uploads/2013/09/Voila_Capture289.png"><br />
</a></li>
</ul>
<h2>Conclusión</h2>
<p>Si no te quieres complicar y el uso que haces de git se limita a hacer commits, push y pull, crear ramas y hacer merge, estás de enhorabuena: estas operaciones puedes hacerlas ya de manera rápida y efectiva en la nueva interfaz.</p>
<p>Ahora bien, si os soy sincero, la mayoría del tiempo sigo teniendo desactivado el soporte git y usando SourceTree y la línea de comandos, como hacía antes. El motivo principal: en cuanto quieres hacer cosas «normales» como un rebase, se te queda corto.</p>
<p>Por último, aunque el formato del fichero hace más sencillo el merging de ramas, sigo siendo escéptico en cuanto al uso de Story Boards. Sólo espero que esto no desemboque en Apple eliminando el soporte para ficheros xib en XCode ¡me tocará hacerlo todo por código!</p>
]]></content:encoded>
					
					<wfw:commentRss>https://aprendegit.com/repaso-rapido-a-las-novedades-de-git-en-xcode-5/feed/</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
		<post-id xmlns="com-wordpress:feed-additions:1">647</post-id>	</item>
		<item>
		<title>Cómo deshacer el último commit en git</title>
		<link>https://aprendegit.com/como-deshacer-el-ultimo-commit-en-git/</link>
					<comments>https://aprendegit.com/como-deshacer-el-ultimo-commit-en-git/#comments</comments>
		
		<dc:creator><![CDATA[alfonso]]></dc:creator>
		<pubDate>Wed, 11 Sep 2013 15:14:32 +0000</pubDate>
				<category><![CDATA[comandos]]></category>
		<guid isPermaLink="false">https://aprendegit.com/?p=630</guid>

					<description><![CDATA[Aquí os dejo una manera sencilla de dar marcha atrás si habéis hecho un commit y os habéis arrepentido de hacerlo. El motivo por el que queréis «borrarlo» puede ser múltiple: porque el trabajo no está terminado y queréis continuar trabajando, habéis introducido un bug sin daos cuenta o sencillamente os habéis equivocado y lo [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>Aquí os dejo una manera sencilla de dar marcha atrás si habéis hecho un commit y os habéis arrepentido de hacerlo. El motivo por el que queréis «borrarlo» puede ser múltiple: porque el trabajo no está terminado y queréis continuar trabajando, habéis introducido un bug sin daos cuenta o sencillamente os habéis equivocado y lo habéis hecho antes de tiempo.</p>
<p>Existen dos maneras de borrar ese commit:</p>
<ul>
<li><span style="line-height: 14px;">Eliminando junto al commit las modificaciones que este contiene</span></li>
<li>Recuperándolas en el área de trabajo para seguir trabajando en ellas</li>
</ul>
<p>En ambos casos, el comando que utilizaremos será «git reset».</p>
<h2>Deshacer el commit perdiendo las modificaciones</h2>
<p>Supongamos que tenemos nuestro repositorio en el siguiente estado:</p>
<p><a href="https://aprendegit.com/wp-content/uploads/2013/09/Voila_Capture283.png"><img loading="lazy" decoding="async" class="aligncenter size-full wp-image-633" alt="Voila_Capture283" src="https://aprendegit.com/wp-content/uploads/2013/09/Voila_Capture283.png" width="670" height="225" srcset="https://aprendegit.com/wp-content/uploads/2013/09/Voila_Capture283.png 670w, https://aprendegit.com/wp-content/uploads/2013/09/Voila_Capture283-300x100.png 300w, https://aprendegit.com/wp-content/uploads/2013/09/Voila_Capture283-624x209.png 624w" sizes="(max-width: 670px) 100vw, 670px" /></a>y queremos deshacer el último commit. En este primer caso, <strong>queremos desechar los cambios introducidos en ese commit</strong> que contiene una serie de tests funcionales.</p>
<p>Para ello, ejecutamos el comando:</p>
<pre>git reset --hard HEAD~1</pre>
<p>Tras ejecutar el comando, el estado del repositorio es el siguiente:</p>
<p><a href="https://aprendegit.com/wp-content/uploads/2013/09/Voila_Capture284.png"><img loading="lazy" decoding="async" class="aligncenter size-full wp-image-634" alt="Repositorio tras borrar el commit" src="https://aprendegit.com/wp-content/uploads/2013/09/Voila_Capture284.png" width="671" height="231" srcset="https://aprendegit.com/wp-content/uploads/2013/09/Voila_Capture284.png 671w, https://aprendegit.com/wp-content/uploads/2013/09/Voila_Capture284-300x103.png 300w, https://aprendegit.com/wp-content/uploads/2013/09/Voila_Capture284-624x214.png 624w" sizes="(max-width: 671px) 100vw, 671px" /></a></p>
<p>Como podéis ver, el commit 600cc08 ha desaparecido que era lo que queríamos. Además, la rama activa se ha desplazado un commit hacia abajo y nuestro área de trabajo ha quedado en el estado del commit 6eb9f2d. Los tests funcionales que estaban en el commit se han perdido y tendríamos que <a title="Git: la he liado parda" href="https://aprendegit.com/git-la-he-liado-parda/">recurrir al reflog</a> para recuperarlos.</p>
<p>La sintaxis HEAD~1 del comando anterior la podríamos traducir como «El commit al que está apuntando la rama activa menos uno». Si hubiésemos ejecutado el comando:</p>
<pre>git reset --hard HEAD~3</pre>
<p>en lugar de acabar en el commit 6eb9f2d (uno por detrás) habríamos acabado en 63db9fa (tres por detrás).</p>
<h2>Deshacer el commit manteniendo las modificaciones</h2>
<p>Existe la posibilidad de eliminar el commit pero manteniendo las modificaciones que contiene ese commit en el área de trabajo. ¿Y por qué querríamos hacer esto? Por varios motivos, por ejemplo por que los tests funcionales del commit 600cc08 están incompletos, son incorrectos o he introducido algún bug en él.</p>
<p>Partiendo de nuevo del mismos estado inicial de antes:</p>
<p><a href="https://aprendegit.com/wp-content/uploads/2013/09/Voila_Capture283.png"><img loading="lazy" decoding="async" class="aligncenter size-full wp-image-633" alt="Estado inicial del repositorio." src="https://aprendegit.com/wp-content/uploads/2013/09/Voila_Capture283.png" width="670" height="225" srcset="https://aprendegit.com/wp-content/uploads/2013/09/Voila_Capture283.png 670w, https://aprendegit.com/wp-content/uploads/2013/09/Voila_Capture283-300x100.png 300w, https://aprendegit.com/wp-content/uploads/2013/09/Voila_Capture283-624x209.png 624w" sizes="(max-width: 670px) 100vw, 670px" /></a>ejecutaríamos el siguiente comando:</p>
<pre>git reset HEAD~1</pre>
<p>Tras lo cual, el estado del repositorio sería:</p>
<p><a href="https://aprendegit.com/wp-content/uploads/2013/09/Voila_Capture285.png"><img loading="lazy" decoding="async" class="aligncenter size-full wp-image-635" alt="Voila_Capture285" src="https://aprendegit.com/wp-content/uploads/2013/09/Voila_Capture285.png" width="668" height="487" srcset="https://aprendegit.com/wp-content/uploads/2013/09/Voila_Capture285.png 668w, https://aprendegit.com/wp-content/uploads/2013/09/Voila_Capture285-300x218.png 300w, https://aprendegit.com/wp-content/uploads/2013/09/Voila_Capture285-624x454.png 624w" sizes="(max-width: 668px) 100vw, 668px" /></a>Si miráis el estado veréis los siguiente:</p>
<ul>
<li><span style="line-height: 14px;">Al igual que en el caso anterior, el commit 600cc08 ha desaparecido</span></li>
<li><span style="line-height: 14px;">La rama activa (rest) ha pasado al apuntar al commit 6eb9f2d</span></li>
<li><span style="line-height: 14px;">A diferencia del  caso anterior, el área de trabajo contiene las modificaciones que estaban en el commit que acabamos de borrar.</span></li>
</ul>
<p>Así que podemos seguir trabajando, corregir el bug o completar los tests que habíamos dejado incompletos y hacer un nuevo commit con los cambios completos. ¡Así de fácil!</p>
<h2>Muy útil pero&#8230;</h2>
<p>Muy importante tener en cuenta que estas dos operaciones sobreescriben la historia del repositorio ¡estamos borrando un commit!. Si estamos trabajando en local y no hemos hecho push a nuestro remoto no hay ningún problema. Si ha habéis hecho push de este commit tened en cuenta que vuestros compañeros lo seguirán viendo si alguna de sus ramas lo referencia.</p>
<p>Espero que os haya resultado útil.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
]]></content:encoded>
					
					<wfw:commentRss>https://aprendegit.com/como-deshacer-el-ultimo-commit-en-git/feed/</wfw:commentRss>
			<slash:comments>15</slash:comments>
		
		
		<post-id xmlns="com-wordpress:feed-additions:1">630</post-id>	</item>
		<item>
		<title>6 motivos por los que git no es un sistema de backup</title>
		<link>https://aprendegit.com/6-motivos-por-los-que-git-no-es-un-sistema-de-backup/</link>
					<comments>https://aprendegit.com/6-motivos-por-los-que-git-no-es-un-sistema-de-backup/#comments</comments>
		
		<dc:creator><![CDATA[alfonso]]></dc:creator>
		<pubDate>Tue, 11 Jun 2013 05:51:35 +0000</pubDate>
				<category><![CDATA[General]]></category>
		<category><![CDATA[backup]]></category>
		<guid isPermaLink="false">https://aprendegit.com/?p=608</guid>

					<description><![CDATA[Esta es una frase que escucho muy a menudo:  “Yo tengo backup de mi repositorio git en github”. Siempre que la escucho acabo teniendo la misma conversación con la persona que la ha dicho. Intento hacerle ver porqué github, bitbucket o cualquier otro servicio de hosting de repositorios no son una copia de seguridad de [&#8230;]]]></description>
										<content:encoded><![CDATA[<p><span style="line-height: 1.714285714; font-size: 1rem;">Esta es una frase que escucho muy a menudo:</span></p>
<pre> “Yo tengo backup de mi repositorio git en github”.</pre>
<p>Siempre que la escucho acabo teniendo la misma conversación con la persona que la ha dicho. Intento hacerle ver porqué github, bitbucket o cualquier otro servicio de hosting de repositorios no son una copia de seguridad de tu repositorio y cómo en determinadas circunstancias (muy habituales cuando trabajas en equipo) puedes perder información por usarlos para lo que no son.</p>
<p>Esto desde el punto de vista práctico. Si escarbamos un poco, lo normal es que detrás de esta frase se esconda un uso no del todo correcto de git o un desconocimiento de ciertas funcionalidades de la herramienta que espero corregir con este artículo.</p>
<p>En adelante me referiré a tu cuenta de github, bitbucket o cualquier otro sistema de hosting de repositorios git como <em>servidor git</em>.</p>
<h2>1- Git es algo más que hacer un commit al final de nuestra jornada</h2>
<p>El flujo más básico de uso de git que me he encontrado es el siguiente:</p>
<ul>
<li><span style="line-height: 14px;">Llego a trabajar por la mañana y trabajo</span></li>
<li>Antes de irme hago un commit</li>
<li>Después del commit hago un push</li>
</ul>
<p>Así, tienes en tu servidor git la última versión del código fuente. Si respetas este flujo, efectivamente tienes una copia de la última versión de tu código fuente en tu servidor. Ahora bien, <strong>no tienes una copia de tu repositorio, porque el repositorio del servidor al que haces push y el de tu máquina local son diferentes. ¡Por eso haces push!</strong></p>
<p>Este forma de trabajo viola varias de las buenas prácticas de git:</p>
<ul>
<li><span style="line-height: 1.714285714; font-size: 1rem;">No estás haciendo commits atómicos, pequeños y muy a menudo. Lo que significa que no estás pensando en cómo gestionar tu código sino en guardar la última versión en un «cajón de sastre» que es tu servidor</span></li>
<li><span style="line-height: 1.714285714; font-size: 1rem;">No estás trabajando con ramas locales para desarrollar funcionalidad</span></li>
<li>Probablemente, no tienes definido ningún flujo de trabajo que te permita gestionar cambios de contexto a la hora de trabajar</li>
</ul>
<h2>2- No estás guardando una copia de tus ramas locales</h2>
<p>Las ramas locales, son eso, ramas locales. Las usas para muchas cosas, entre ellas para hacer pruebas, hacer refactorings del código o desarrollar funcionalidades en paralelo. Al no hacer push, de estas ramas, no tienes copia de los commits en tu servidor git.</p>
<p>Sé lo que estás pensando, basta con hacer push de todas las ramas y ya está. Bien, eso es correcto si estás tu solo con tu repositorio. Ahora bien, si estás trabajando en equipo y todos vosotros compartís el mismo repositorio git, la cosa cambia ¿Te imaginas a 5 personas todas subiendo sus ramas de prueba al servidor git para tener copia de seguridad? El caos está garantizado si no se organiza todo muy, muy, muy bien.</p>
<h2>3- No estás guardando una copia del reflog</h2>
<p>El reflog es un fichero de log que está en la carpeta .git de tu repositorio local donde se guarda un log de todos los cambios de referencias que ocurren en tu repositorio. Cada vez que cambias de rama, haces un merge, un rebase, un pull o un cherry-pick (entre otros) se guarda en el reflog lo que ha pasado.</p>
<p>Este fichero es el que te permite dar marcha atrás cuando la lías parda. Échale un vistazo a <a title="Git: la he liado parda" href="https://aprendegit.com/git-la-he-liado-parda/">este hangout</a> para un ejemplo sobre cómo se usa.</p>
<p>Tu reflog no está en tu servidor git. El servidor git tiene su propio reflog que no tiene porqué coincidir con el tuyo. De nuevo, si estás tu solo y haces push de todas tus ramas, el reflog del servidor se parecerá mucho al tuyo. Eso sí, en caso de desastre, tendrás que entrar al servidor a verlo o copiartelo a tu máquina local&#8230; oh, vaya, espera, que estás trabajando con github / bitbucket y no te dejan entrar a sus servidores a descargarte el reflog, desde luego qué tíos perros ¿no?.</p>
<p>Si estás trabajando en equipo, el reflog del servidor tiene todas las modificaciones de referencias hechas por tí y el resto del equipo. ¡Intentar encontrar algo en ese reflog es garantía de diversión durante horas!</p>
<h2>4- No tienes backup de los hooks de tu repositorio git</h2>
<p>Dentro de la carpeta .git/hooks de tu repositorio puedes poner <a href="http://git-scm.com/book/es/Personalizando-Git-Puntos-de-enganche-Git">hooks</a>. Estos hooks no son más que scripts que se ejecutan antes o después de los comandos git y que te permiten interceptar la ejecución para hacer «cosas». Por ejemplo, el &#8216;pre-commit&#8217; te permite manipular dinámicamente el mensaje del commit que se genera por defecto.</p>
<p>Cualquier hook que hayas puesto en tu máquina local en la carpeta .git/hooks, no tiene copia de seguridad en tu servidor git.</p>
<h2>5- No tienes backup de tu configuración local</h2>
<p>Dentro de tu repositorio tienes un fichero con la configuración local de tu repositorio: .git/config. En este fichero puedes guardar varias cosas, entre ellas el nombre y correo electrónico del autor de los commits, alisas de comandos de esos molones que te has bajado de internet y, en general, opciones de configuración específicas de ese repositorio en esa máquina.</p>
<p>Este fichero tampoco se sube a tu servidor git, así que en caso de desastre, lo pierdes y tienes que volver a generar la configuración del repositorio.</p>
<h2>6- git permite sobreescribir la historia de tu repositorio</h2>
<p>Si trabajas con más gente, en tu repositorio no vas a estar hurgando solo tú. Tendrás código de otras personas, harás merges o pull requests. Hay alguien que puede estar tocando el repositorio detrás de tí así que entre el momento que ocurre el desastre y «recuperas» el repositorio haciendo un clon, muchas cosas pueden haber cambiado.</p>
<p>Ponte en esta situación: te vas de vacaciones mientras tus compañeros trabajan en el repositorio. A la vuelta tu disco duro ha muerto, o durante el viaje te roban el portátil, así que clonas de nuevo el repositorio y te pones a trabajar… Lo que vas a clonar no es lo que tenías antes de irte, el repositorio contendrá todos los cambios que tus compañeros han hecho en tu ausencia.</p>
<p>Me dirás: “tío, no tienes ni idea. Una vez clonado hago un reset al commit de antes de irme de vacaciones y ya está”… Y yo te digo ¿Y no sabes que tus compañeros del alma pueden haberse cargado esos commits con un rebase, por ejemplo?. Recuerda: git, a diferencia de mercurial, permite sobreescribir la historia del repositorio así que ¡¡nada te garantiza que cuando vuelvas de tus vacaciones los commits sigan ahí!!</p>
<h1><span style="line-height: 1.714285714; font-size: 1rem;">Conclusión</span></h1>
<p><span style="line-height: 1.714285714; font-size: 1rem;">Según la </span><a style="line-height: 1.714285714; font-size: 1rem;" href="http://en.wikipedia.org/wiki/Backup">wikipedia</a><span style="line-height: 1.714285714; font-size: 1rem;">:</span></p>
<pre>a backup, or the process of backing up, refers to the copying and archiving of 
computer data so it may be used to restore the original after a data loss event.</pre>
<p>Si pierdes tu disco duro, y recuperas un repositorio haciendo un nuevo clon, no estás recuperando el repositorio como lo tenías antes del desastre así que según esta definición, no es una copia de seguridad. Además ¿Tú crees que Linus Torvalds hizo git para esto? ¿Para hacer backup? ¡eso ya lo tenía con los ficheros tar con los que empezó! Si solo lo usas para hacer copias de respaldo te estás perdiendo muchas cosas.</p>
<p><span style="line-height: 1.714285714; font-size: 1rem;">Git no es un sistema de copia de seguridad de nuestro código. Ahora bien, si se dan estas condiciones:</span></p>
<ol>
<li>Estás trabajando tú solo</li>
<li>Haces push de todos los commits al repositorio remoto</li>
<li>Todas las ramas que creas son remotas</li>
<li>Tienes un repositorio que llamas scripts_y_configuracion en el que guardas los hooks, alias, pro-tips y configuraciones personalizadas de tus repositorios.</li>
</ol>
<p>y eres consciente de lo que estás haciendo, <strong>puedes utilizar github como un backup (parcial) de tu código fuente, no de tu repositorio.</strong></p>
<p>De igual manera, si trabajas en equipo y cada integrante tiene su propio repositorio, cada uno de vosotros podría usar git de esta manera. Aunque es un flujo muy básico que sirve para empezar a trabajar, no lo recomiendo en casi ningún caso: en seguida se te queda corto.</p>
<p>En mi caso particular, TimeMachine me ha salvado ya en varias ocasiones de problemas, ahorrándome mucho tiempo y trabajo. <b>Aquí tienes mi consejo: usa una herramienta de backups para hacer backups y una herramienta de gestión de código para gestionar código.</b></p>
]]></content:encoded>
					
					<wfw:commentRss>https://aprendegit.com/6-motivos-por-los-que-git-no-es-un-sistema-de-backup/feed/</wfw:commentRss>
			<slash:comments>7</slash:comments>
		
		
		<post-id xmlns="com-wordpress:feed-additions:1">608</post-id>	</item>
		<item>
		<title>git-merge 2013: hack day y como no, cerveza</title>
		<link>https://aprendegit.com/git-merge-2013-hack-day-y-como-no-cerveza/</link>
					<comments>https://aprendegit.com/git-merge-2013-hack-day-y-como-no-cerveza/#comments</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Mon, 13 May 2013 19:49:07 +0000</pubDate>
				<category><![CDATA[Eventos / charlas / conferencias]]></category>
		<guid isPermaLink="false">https://aprendegit.com/?p=592</guid>

					<description><![CDATA[Hace un par de días os escribía un resumen del Git Merge User Day. Aquí os dejo mis impresiones sobre el Hack Day. Durante el desayuno, compartí mesa, entre otros, con  Thomas Ferris Nicolaisen, que produce el podcast gitminutes.com. Su entusiasmo por lo que hace y cómo lo cuenta es especialmente motivador y me ha [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>Hace un par de días os escribía un resumen del <a title="git-merge 2013: user day" href="https://aprendegit.com/git-merge-2013-user-day/">Git Merge User Day</a>. Aquí os dejo mis impresiones sobre el Hack Day.</p>
<p>Durante el desayuno, compartí mesa, entre otros, con  <a title="author profile" href="https://plus.google.com/101470099289717563604" rel="author">Thomas Ferris Nicolaisen</a>, que produce el podcast <a href="gitminutes.com">gitminutes.com</a>. Su entusiasmo por lo que hace y cómo lo cuenta es especialmente motivador y me ha dado un par de buenos consejos para el blog que confío en poner en práctica en breve. Estaba, además, muy interesado en cómo está funcionando tanto este blog como los cursos de git así que estuvimos compartiendo datos de Google Analytics e intercambiando experiencias.</p>
<p>Compartiendo la mesa estaba con nosotros Scott Chacon, que nos estuvo contando cómo utilizan en github algunas de las herramientas para trabajar colaborativamente. Me quedé con dos ejemplos sobre cómo utilizan <a href="http://campfirenow.com/">campfire</a>:</p>
<ul>
<li><span style="line-height: 1.714285714; font-size: 1rem;">Cuando se nombra a una persona en una sala, esta recibe un aviso y puede eventualmente unirse o responder offline si la sala ya está cerrada cuando se intenta conectar.</span></li>
<li>Meten las conversaciones de campfire en Elastic Search y luego utilizan el motor para buscar las conversaciones. Antes de esta combinación, aparentemente se perdía mucha información que luego no podía encontrarse de nuevo.</li>
</ul>
<p><span style="font-size: 1rem; line-height: 1.714285714;">Curioso ¿verdad? Con estas «simples» modificaciones el ratio de participación en las conversaciones se disparó, así como la utilidad de la herramienta. También interesante cómo han ido evolucionando del «stupid drinking» al «we still drink a lot» con un, digamos, consumo responsable. Scott comentó durante el desayuno dos comandos que no conocía: git-fast-import y git-fast-export. Bastante útiles para mover commits de un sitio a otro sin hacer rebase (básicamente es copiar commits).</span></p>
<p>Después del desayuno empezamos a trabajar. Yo decidí hablar un poco más con Thomas, que me entrevistó para su podcast. Cuando terminé estuve charlando con algunas de las personas que hablaron el día anterior y aproveché una buena parte de la mañana para organizar las notas y avanzar lo máximo posible en los posts.</p>
<p>Después de comer empecé un pequeño proyecto en ruby que, utilizando <a href="https://github.com/libgit2/rugged">rugged</a>, me permite generar repositorios con commits y ramas predeterminadas. Situación muy habitual: te preguntan algo sobre un rebase y para responder necesitas un repositorio con dos ramas y varios commits en cada una de ellas. Antes empleaba unos 2-3 minutos en crear los commits y las ramas. Con esta herramienta puedo hacerlo en segundos. Está bastante verde, cuando la tenga un poco más pulida la liberaré. La verdad es que para dos horas que le dediqué al tema no está nada mal. Lo bueno de este tipo de eventos es tener a mano a la persona que te puede sacar del atolladero. En mi caso fue <a href="https://github.com/carlosmn">Carlos Martín Nieto</a>, que me ayudó a desatascarme cuando no veía por dónde seguir.</p>
<p>Por la noche estuvimos en el <a href="http://www.golgatha-berlin.de/">Golgatha Biergarten</a>. El nombre prometía y el DrinkUp desde luego no defraudó: para alguien que no le gusta la cerveza, beberse un litro y medio en una noche es todo un logro. Lo acompañé de un par de salchichas o tres (ya no me cuerdo). La verdad es que con un par de cervezas de ese tamaño en el cuerpo es más fácil romper el hielo así que seguimos hablando un poco de git, arreglando los problemas de España y comentando la cantidad de Españoles que había últimamente en Berlín. Como dijo <a href="https://github.com/porras">Sergio</a>: es la venganza por la «ocupación» Alemana de Mallorca.</p>
<p>Os animo a que asistáis a este tipo de eventos, y si es fuera de España mejor. Se aprende mucho compartiendo con gente de otros países. Hacía casi un año que no salía fuera y lo echaba de menos. El próximo viaje es el iOS Dev UK. Ya os contaré.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://aprendegit.com/git-merge-2013-hack-day-y-como-no-cerveza/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
		<post-id xmlns="com-wordpress:feed-additions:1">592</post-id>	</item>
		<item>
		<title>git-merge 2013: user day</title>
		<link>https://aprendegit.com/git-merge-2013-user-day/</link>
					<comments>https://aprendegit.com/git-merge-2013-user-day/#comments</comments>
		
		<dc:creator><![CDATA[alfonso]]></dc:creator>
		<pubDate>Sat, 11 May 2013 10:28:22 +0000</pubDate>
				<category><![CDATA[Eventos / charlas / conferencias]]></category>
		<guid isPermaLink="false">https://aprendegit.com/?p=578</guid>

					<description><![CDATA[&#160; Estamos en Berlín en pleno Git Merge Hack Day. Ayer fue el user day en git-merge 2013, la conferencia para usuarios de git que Github ha organizado en la capital alemana este fin de semana.  A primera hora registro y café y un ratito de networking hasta que ha dado comienzo la conferencia. El formato [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>&nbsp;</p>
<p><span style="line-height: 1.714285714; font-size: 1rem;">Estamos en Berlín en pleno <a title="git-merge 2013: hack day y como no, cerveza" href="https://aprendegit.com/git-merge-2013-hack-day-y-como-no-cerveza/">Git Merge Hack Day</a>. Ayer fue el user day en git-merge 2013, la conferencia para usuarios de git que Github ha organizado en la capital alemana este fin de semana. </span></p>
<p><em id="__mceDel"><span style="line-height: 1.714285714; font-size: 1rem;"><a href="https://aprendegit.com/wp-content/uploads/2013/05/IMG_0489.jpg"><img loading="lazy" decoding="async" class="aligncenter size-full wp-image-585" alt="git-merge 2013" src="https://aprendegit.com/wp-content/uploads/2013/05/IMG_0489.jpg" width="3264" height="2448" srcset="https://aprendegit.com/wp-content/uploads/2013/05/IMG_0489.jpg 3264w, https://aprendegit.com/wp-content/uploads/2013/05/IMG_0489-300x225.jpg 300w, https://aprendegit.com/wp-content/uploads/2013/05/IMG_0489-1024x768.jpg 1024w, https://aprendegit.com/wp-content/uploads/2013/05/IMG_0489-624x467.jpg 624w" sizes="(max-width: 3264px) 100vw, 3264px" /></a></span></em></p>
<p>A primera hora registro y café y un ratito de networking hasta que ha dado comienzo la conferencia. El formato ha sido abierto y muy, como no, colaborativo (muy github):</p>
<ul>
<li>Lightning Talks hasta la hora de la comida</li>
<li>Tarde libre en formato “open space” en el que se proponían temas para hablar sobre ellos</li>
</ul>
<p>Para los que no sepáis lo que son las Lightning Talks, podemos resumirlo en lo siguiente: “el que tenga algo que compartir que salga y lo haga”.</p>
<p>Y la verdad es que ha salido bastante gente a compartir herramientas, presentarse, sugerir temas de conversación para la tarde o contar el último proyecto en el que estaba trabajando:</p>
<ul>
<li>El primero ha empezado con fuerza. Un plugin para integrar XCode con Github disponible vía “Alcatraz”. Podéis encontrarlo aquí: <a href="https://github.com/larsxschneider/ShowInGitHub">https://github.com/larsxschneider/ShowInGitHub</a>. Está todavía en desarrollo aunque la verdad es que promete bastante.</li>
<li>Luego nos han presentado una iniciativa para hacer públicas las discusiones de los parlamentarios a medida que las leyes se van elaborando. ¿Os imagináis a nuestros queridos políticos haciendo un merge de la ley antipiratería y luego haciendo un pull request para incluir sus modificaciones y comentarlas con el resto de grupos? No, yo tampoco. Hay sitios en los que esto pasa. Esto es madurez democrática y lo demás son tonterías. Aquí tenéis el repositorio y el listado de leyes: <a href="https://github.com/Bundestag">https://github.com/Bundestag</a> y <a href="http://bundestag.github.io/gesetze/">http://bundestag.github.io/gesetze/</a> (en Alemán).</li>
<li>Dos de los desarrolladores de git-submodules han presentado rápidamente las novedades que están implementando (<a href="https://github.com/jlehmann/git-submod-enhancements/wiki">https://github.com/jlehmann/git-submod-enhancements/wiki</a>).</li>
<li>Christian Couder nos ha contado lo potente que es git-bisect para localizar bugs (<a href="http://es.slideshare.net/ChristianCouder/enjoy-fighting-regressionswithgitbisect">http://es.slideshare.net/ChristianCouder/enjoy-fighting-regressionswithgitbisect</a>). Además, es muy fácil automatizar la búsqueda con un test y, una vez localizado, corregirlo y crear un commit con la solución y el script de testeo. En una encuesta / estudio realizado entre 40 desarrolladores se ha observado un 40% menos de bugs y hasta un 80% de reducción en el tiempo de localización y depuración del bug cuando se utiliza con TDD. Una herramienta para tener en cuenta. En una intervención posterior, una persona de Ericsson ha compartido con nosotros como utilizó git bisect para detectar y corregir un bug en perl.</li>
<li>Roberto Tyley nos ha presentado BFG-repo-cleaner, una herramienta escrita en Scala que multiplica por mucho la velocidad de git-filter-branch: <a href="http://rtyley.github.io/bfg-repo-cleaner/">http://rtyley.github.io/bfg-repo-cleaner/</a>. En este enlace tenéis un vídeo que compara el rendimiento de un raspberry-pi usando su herramienta vs un MacBook Pro usando git-filter-branch&#8230; por supuesto gana la RaspberryPi.</li>
<li>Michael Haggerty ha presentado git-imerge, una herramienta para hacer merges incrementales entre ramas de larga duración (<a href="http://softwareswirl.blogspot.de/2013/05/git-incremental-merge.html">http://softwareswirl.blogspot.de/2013/05/git-incremental-merge.html</a>, <a href="https://github.com/mhagger/git-imerge">https://github.com/mhagger/git-imerge</a>). Muchas vences me habréis oído decir “no dejes el merge para el final”, haz merge a menudo para resolver los conflictos poco a poco. Puesta esta herramienta facilita esta tarea. Está todavía en modo experimental, seguiremos su evolución con atención porque es realmente útil.</li>
<li>Jack Pearkes ha presentado <a href="https://github.com/pearkes/get">get</a> una herramienta escrita en Go y pensada para hacer fetch de una cuenta de github y todos sus repositorios. Siguiendo con el ejemplo que ha puesto Jack, antes de salir de casa con el portátil, me hago un fetch de todos los repositorios de mi cuenta y me voy al tren con todos actualizados.</li>
<li>Filip Noetzel ha hablado de dos proyectos <a href="https://github.com/peritus/bumpversion">bumpversion</a> y <a href="http://www.geocommit.com/">geocommit</a>. El primero sirve para actualizar todas las cadenas de versión de un programa, crear un commit y etiquetarlo. Está escrito en python y nos puede ahorrar trabajo a la hora de generar una nueva versión de nuestra aplicación. El segundo, geocommit, es un servicio que geolocaliza los commits y nos ayuda a ver de dónde vienen las contribuciones a un proyecto.</li>
<li>Una persona nos ha presentado <a href="http://github.com/acaudwell/Gource">gource</a>. Digo una persona porque no me he quedado con su nombre y no era el que lo ha desarrollado. Es una aplicación que lee el repositorio y hace una animación de cómo evoluciona un repositorio. Muy chulo el resultado para repositorios grandes con muchos participantes. Después de esto las pantallas han estado mostrando la animación del repositorio de git el resto del día.</li>
<li>Se hicieron varias presentaciones sobre <a href="http://libgit2.github.com/">libgit2</a>. En este momento es la niña bonita de Github ya que como nos contó Vicent Martí en la presentación (<a href="http://vimeo.com/64716825">http://vimeo.com/64716825</a>) les ha permitido resolver varios problemas de escalabilidad en el backend. Se trata de una implementación de git empaquetada en una librería en C de forma que puede utilizarse en cualquier aplicación. ¿Te imaginas poder hacer un commit desde una aplicación echa por tí en ruby o python? Pues esto es, entre otras cosas, lo que permite hacer libgit2. La librería está bastante madura y tiene bindings para muchos lenguajes (lo siento, parece que Java no es uno de ellos de momento).</li>
<li>Relacionado con libgit2, tuvimos dos presentaciones de personal de Microsoft en la que nos mostraron cómo instalar y usar el plugin de git en Visual Studio 2012 y cómo clonar un repositorio alojado en TFS usando <a href="http://gittf.codeplex.com/">git-tf</a>. Parece que dentro de poco Visual Studio ya incluirá el soporte de git nativo y no será necesario instalar ningún plugin.</li>
<li>Mislav Marohnić nos presenta <a href="http://defunkt.io/hub/">hub</a> una herramienta escrita en ruby para trabajar con repositorios github desde la línea de comandos. Github la utiliza en sus cursos intermedios/avanzados.</li>
<li>Sergei nos presentó una herramienta para enseñar git bastante curiosa, muy parecida a <a href="http://pcottle.github.io/learnGitBranching/">http://pcottle.github.io/learnGitBranching/</a>. Aunque el código no está en este momento abierto sí se puede usar en este enlace <a href="http://io.git-init.ru/git-trainer/">http://io.git-init.ru/git-trainer/</a></li>
<li>Matthew McCullough nos habló sobre los recursos que github ha puesto a disposición de la comunidad para aprender git: teach.github.com, learn.github.com y <a href="http://www.youtube.com/github">www.youtube.com/github</a>.</li>
<li>Simon nos presentó <a href="http://subgit.com/">subgit</a> una herramienta que permite utilizar un repositorio tanto con clientes subversion como con clientes git. Si trabajas con los dos sistemas o te estás planteando una migración, esta puede ser una herramienta muy útil.</li>
<li>Jetbrains hos nizo una rápida exposición de algunas de las mejoras en las que están trabajando para el cliente git que incluyen en sus IDE. Me gustó mucho lo que ellos llaman “smart checkout” que básicamente es un stash-checkout-unstash, muy útil cuando has hecho varias modificaciones en el código en la rama que no era. También mostraron una nueva característica: cuando te rechazan un push porque tus referencias no están actualizadas, tienes que volver hacer un pull y luego volver a hacer el push. En las próximas versiones, Jetbrains lo hará por nosotros dándonos la opción la hacer el pull con un merge o con un rebase. Estos chicos siempre pensando en que trabajemos menos&#8230;(<a href="http://www.jetbrains.com/idea/webhelp/using-git-integration.html">http://www.jetbrains.com/idea/webhelp/using-git-integration.html</a>)</li>
<li>Nos enseñan otro proyecto muy curioso: <a href="https://github.com/kripken/emscripten">emscripten</a>. Se trata de un compilador LLVM-to-Javascript, es decir, coge LLVM Bitcode y lo transforma en javascript&#8230; ¿qué excusa tenéis ahora para no escribir javascript?</li>
<li>Sergio Gil, con el que tuve el placer de estar charlando un buen rato durante la tarde, nos presentó <a href="https://github.com/porras/ghcontributors">GHContributors</a> (<a href="http://ghcontributors.herokuapp.com/">http://ghcontributors.herokuapp.com/</a>) una web que nos muestra todas las contribuciones que un usuario ha hecho a github.</li>
<li><a href="http://www.versioneye.com/">http://www.versioneye.com/</a> un servicio que monitoriza las librerías que utilizas en tu proyecto y te avisa cuando cambian de versión.</li>
<li>Para cerrar la sesión, Scott Chacon nos habló del portal git-scm.com/community. Como el mismo dijo, una página para usuarios de git, no para desarrolladores. Nos estuvo hablando del libro (<a href="http://www.github.com/progit/progit">http://www.github.com/progit/progit</a>) y de los planes que tiene para la segunda edición, que quiere escribir contando con la colaboración más activa de usuarios y desarrolladores. También se habló de la traducción del libro, que os recuerdo se realiza a través de la comunidad, y nos habló de que en github se están planteando incluso la contratación de traductores profesionales para mejorar ese aspecto. Por supuesto no dio fechas ni plasmaron un compromiso formal sobre ello, lo plantearon como opción para ayudar a resolver el problema que se plantea con un tema tan complicado como es la traducción. En esta discusión, que continuó más tarde en el grupo de formación en git, contamos con la experiencia de Axel Hecht (Mozilla) y cómo gestionan ellos las traducciones de sus herramientas.</li>
<li>Para terminar las ligthning talks, Scott nos recordó, por si se nos había olvidado, que github es el servidor de repositorios subversion más grande del mundo. Basta con que hagáis un checkout de cualquier repositorio de git con vuestro cliente favorito de subversion:</li>
</ul>
<pre>svn checkout https://github.com/progit/progit</pre>
<p><a href="https://aprendegit.com/wp-content/uploads/2013/05/IMG_0490.jpg"><img loading="lazy" decoding="async" class="wp-image-586 alignleft" alt="IMG_0490" src="https://aprendegit.com/wp-content/uploads/2013/05/IMG_0490.jpg" width="300" height="400" srcset="https://aprendegit.com/wp-content/uploads/2013/05/IMG_0490.jpg 2448w, https://aprendegit.com/wp-content/uploads/2013/05/IMG_0490-225x300.jpg 225w, https://aprendegit.com/wp-content/uploads/2013/05/IMG_0490-768x1024.jpg 768w, https://aprendegit.com/wp-content/uploads/2013/05/IMG_0490-624x832.jpg 624w" sizes="(max-width: 300px) 100vw, 300px" /></a></p>
<p>Después de las charlas, se establecieron varios grupos en los que se habló de diferentes temas: formación, migración a git, traducción de material y recursos. Matthew McCullough y Brent Beer estuvieron hablando sobre cómo enseñan git y github en diferentes partes del mundo. Entre las 10 personas que estuvimos charlando e intercambiando experiencias, había dos corrientes: los que mostraban el grafo desde el primer momento y los que preferían esperar un poco antes de mostrar las famosas “pelotas con padres”. La conversación fue muy productiva con ideas y un notas para mejorar los cursos de git.</p>
<p>En paralelo a esta conversación sobre formación en git, tuvo lugar otra muy interesante sobre migración. Como por el momento no he desarrollado la capacidad de estar en dos sitios a la vez, Peter Jönsson (<a href="https://github.com/mindjiver">https://github.com/mindjiver</a>) and Andrey Devyatkin (<a href="https://github.com/Andrey9kin">https://github.com/Andrey9kin</a>) tuvieron la gentileza de volver a hablar conmigo sobre cómo hicieron en Ericsson una migración de Clear Case a git que afectó a mil personas. Lo primero que hicieron fue formar un equipo de 8 personas que durante los casi dos años que duró el proceso se dedicaron en exclusiva a ese proyecto. Dado que tenían un alto grado de personalización en la instalación que tenían de Clear Case, tuvieron que realizar varias herramientas a medida para implementar la funcionalidad que necesitaban. De echo, 4 de las personas del equipo eran programadores de backend y frontend dedicados a la aplicación que han desarrollado. Una de las necesidades que tenían era el almacenamiento de metadatos en los repositorios y me estuvieron comentando que de las tres opciones que tenían (mensaje del commit, git-notes y etiquetas) finalmente optaron por almacenarlos en el mensaje del commit y desarrollar un parser con expresiones regulares para extraer y buscar la información. Comentamos opciones como almacenarlos en una base de datos (SQL o NoSQL) aunque no era para ellos una opción por complicar la infraestructura más de lo necesario.</p>
<p>Si algo saco en claro de la experiencia tanto mía como de las conversaciones que tengo con cualquier persona que afronta una migración en git es que no es un proceso sencillo. Requiere planificación y una adecuada ejecución, y aunque lo que se gana es mucho, el proceso es doloroso y requiere compromiso de todo el equipo para poder llevarlo a cabo con éxito.</p>
<p>Como veis un día muy intenso y productivo. <a title="git-merge 2013: hack day y como no, cerveza" href="https://aprendegit.com/git-merge-2013-hack-day-y-como-no-cerveza/">Veremos cómo se desarrolla el hack-day</a>.</p>
<h2>Más enlaces</h2>
<ul>
<li><span style="line-height: 14px;"><a href="https://github.com/git-merge/user-day/blob/master/docs/01-index.md">https://github.com/git-merge/user-day/blob/master/docs/01-index.md</a></span></li>
<li><a title="git-merge 2013: hack day y como no, cerveza" href="https://aprendegit.com/git-merge-2013-hack-day-y-como-no-cerveza/">Resumen e impresiones sobre el Hack Day</a></li>
</ul>
<p><a href="https://aprendegit.com/wp-content/uploads/2013/05/IMG_0487.jpg"><img loading="lazy" decoding="async" class="aligncenter size-full wp-image-584" alt="git-merge-2013" src="https://aprendegit.com/wp-content/uploads/2013/05/IMG_0487.jpg" width="3264" height="2448" srcset="https://aprendegit.com/wp-content/uploads/2013/05/IMG_0487.jpg 3264w, https://aprendegit.com/wp-content/uploads/2013/05/IMG_0487-300x225.jpg 300w, https://aprendegit.com/wp-content/uploads/2013/05/IMG_0487-1024x768.jpg 1024w, https://aprendegit.com/wp-content/uploads/2013/05/IMG_0487-624x467.jpg 624w" sizes="(max-width: 3264px) 100vw, 3264px" /></a></p>
]]></content:encoded>
					
					<wfw:commentRss>https://aprendegit.com/git-merge-2013-user-day/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
		<post-id xmlns="com-wordpress:feed-additions:1">578</post-id>	</item>
		<item>
		<title>Todo listo para el git-merge 2013 de Berlín</title>
		<link>https://aprendegit.com/todo-listo-para-el-git-merge-2013-de-berlin/</link>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Wed, 08 May 2013 15:00:25 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<guid isPermaLink="false">https://aprendegit.com/?p=573</guid>

					<description><![CDATA[Bueno, pues llegó el día&#8230; o casi. Mañana a estas horas estaré ya en Berlín para asistir al git-merge que ha organizado Github. La verdad es que esto de ir a congresos «de friquis» me encanta, así que estoy como un niño la noche antes de que lleguen los reyes magos. El programa promete&#8230; porque no [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>Bueno, pues llegó el día&#8230; o casi. Mañana a estas horas estaré ya en Berlín para asistir al <a href="http://git-merge.com/">git-merge que ha organizado Github</a>.</p>
<p>La verdad es que esto de ir a congresos «de friquis» me encanta, así que estoy como un niño la noche antes de que lleguen los reyes magos.</p>
<p>El programa promete&#8230; porque no hay programa así que el evento que va a ser bastante abierto. El primer día, el jueves, está reservado para los «contributors». El segundo tendremos un formato un-conference / lightning talks y el sábado será el hack day. Y como no, el motivo real por el que todos vamos a Berlín, que es el cierre del evento el sábado por la noche en el Golgatha Biergarten ¡Github drinkup!</p>
<p>Contará con la presencia de <a href="https://twitter.com/matthewmccull">Matthew McCullough</a>, <a href="https://twitter.com/vmg">Vicent Marti</a> o  <a href="http://www.tfnico.com/">Thomas Ferris Nicolaisen</a>, director del podcast «<a href="http://www.gitminutes.com/">Git Minutes</a>«. Con muchas ganas de ponerle cara a personas que llevo tiempo siguiendo y que han cambiado nuestra forma de trabajar. A la vuelta os contaré qué tal ha ido el evento.</p>
<p>¡Hasta la semana que viene!</p>
]]></content:encoded>
					
		
		
		<post-id xmlns="com-wordpress:feed-additions:1">573</post-id>	</item>
		<item>
		<title>Introducción a git en Betabeers Badajoz</title>
		<link>https://aprendegit.com/introduccion-a-git-en-betabeers-badajoz/</link>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Tue, 07 May 2013 08:00:09 +0000</pubDate>
				<category><![CDATA[introducción]]></category>
		<category><![CDATA[presentación]]></category>
		<category><![CDATA[vídeo]]></category>
		<guid isPermaLink="false">https://aprendegit.com/?p=569</guid>

					<description><![CDATA[Hola de nuevo: Coincidiendo con el curso de git que impartimos en Badajoz, dimos una presentación de 40 minutos de introducción a git. La charla fue grabada y la podéis ver en youtube. Ese mismo día, Álvaro de la Mata compartió con todos nosotros cómo cambiaron la forma de trabajo de toda la empresa aplicando [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>Hola de nuevo:</p>
<p>Coincidiendo con el <a href="http://www.cursodegit.com/cursos-y-eventos/entendiendo-git-badajoz-abril-2013/">curso de git</a> que impartimos en Badajoz, dimos una presentación de 40 minutos de introducción a git. La charla fue grabada y la podéis <a href="http://www.youtube.com/watch?v=x-YQS7Omrhw">ver en youtube</a>.<br />
<iframe loading="lazy" src="http://www.youtube.com/embed/x-YQS7Omrhw" height="360" width="640" allowfullscreen="" frameborder="0"></iframe></p>
<p>Ese mismo día, Álvaro de la Mata compartió con todos nosotros cómo cambiaron la forma de trabajo de toda la empresa aplicando metodologías ágiles en una charla que no tiene desperdicio. Aunque no se habla de git explícitamente, git y agilismo van bastante de la mano así que aquí os <a href="http://www.youtube.com/watch?v=_BBRdeB2bdY">dejo el enlace</a>.</p>
]]></content:encoded>
					
		
		
		<post-id xmlns="com-wordpress:feed-additions:1">569</post-id>	</item>
		<item>
		<title>Git: la he liado parda</title>
		<link>https://aprendegit.com/git-la-he-liado-parda/</link>
					<comments>https://aprendegit.com/git-la-he-liado-parda/#comments</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Thu, 25 Apr 2013 06:37:55 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<guid isPermaLink="false">https://aprendegit.com/?p=563</guid>

					<description><![CDATA[Aquí os dejo el vídeo de la presentación que hice ayer (24 de abril de 2013) en el grupo de desarrolladores de Symfony de Madrid. Una presentación de una hora en la que hablamos de las herramientas que nos da git para no tener que recurrir al famoso borrar-y-volver-a-clonar-repositorio para recuperar nuestro repo cuando nos [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>Aquí os dejo el vídeo de la presentación que hice ayer (24 de abril de 2013) en el <a href="http://www.symfony-madrid.es/">grupo de desarrolladores de Symfony de Madrid</a>.</p>
<p>Una presentación de una hora en la que hablamos de las herramientas que nos da git para no tener que recurrir al famoso borrar-y-volver-a-clonar-repositorio para recuperar nuestro repo cuando nos equivocamos.</p>
<p>Durante la presentación hacemos varias demos:</p>
<ul>
<li><span style="line-height: 1.714285714; font-size: 1rem;">Cómo detener un merge que nos ha dado conflictos</span></li>
<li><span style="line-height: 1.714285714; font-size: 1rem;">Cómo deshacer un merge una vez finalizado</span></li>
<li><span style="line-height: 1.714285714; font-size: 1rem;">Cómo deshacer un rebase que hemos hecho al revés, sobreescribiendo la historia del repositorio</span></li>
<li><span style="line-height: 1.714285714; font-size: 1rem;">Cómo usar git-bisect para encontrar un bug</span></li>
<li><span style="line-height: 1.714285714; font-size: 1rem;">Cómo usar git-revert para solucionarlo</span></li>
</ul>
<p><span style="font-size: 1rem; line-height: 1.714285714;">¡No está mal para una hora! Espero que os guste y os resulte útil.</span><span style="font-size: 1rem; line-height: 1.714285714;"><br />
</span></p>
<p>Aprovechamos para recordaros que en Aprendegit estamos siempre dispuestos para dar charlas y presentaciones sobre nuestra herramienta favorita. Así que si quieres que vayamos a hablar de git a cualquier sitio, sólo tienes que proponernoslo <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f609.png" alt="😉" class="wp-smiley" style="height: 1em; max-height: 1em;" /></p>
<p><iframe loading="lazy" src="http://www.youtube.com/embed/aF-zt73Zm5I" height="315" width="560" allowfullscreen="" frameborder="0"></iframe></p>
]]></content:encoded>
					
					<wfw:commentRss>https://aprendegit.com/git-la-he-liado-parda/feed/</wfw:commentRss>
			<slash:comments>8</slash:comments>
		
		
		<post-id xmlns="com-wordpress:feed-additions:1">563</post-id>	</item>
		<item>
		<title>Uso avanzado de referencias: github y pull requests</title>
		<link>https://aprendegit.com/uso-avanzado-de-referencias-github-y-pull-requests/</link>
					<comments>https://aprendegit.com/uso-avanzado-de-referencias-github-y-pull-requests/#comments</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Mon, 22 Apr 2013 08:00:38 +0000</pubDate>
				<category><![CDATA[github]]></category>
		<category><![CDATA[configuración]]></category>
		<category><![CDATA[pull-request]]></category>
		<category><![CDATA[referencias]]></category>
		<guid isPermaLink="false">https://aprendegit.com/?p=544</guid>

					<description><![CDATA[El viernes pasado (19 de abril de 2013) Jesús Espino dio una charla titulada «Git internals» en Kaleidos. Lo primero que es digno de mención es que una empresa de una «charla interna» e invite a cualquiera que quiera asistir «de fuera». Iniciativas como esta deberían estar a la orden del día en empresas en todo [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>El viernes pasado (19 de abril de 2013) <a href="http://twitter.com/jespinog">Jesús Espino</a> dio una charla titulada «Git internals» en <a href="http://kaleidos.net">Kaleidos</a>. Lo primero que es digno de mención es que una empresa de una «charla interna» e invite a cualquiera que quiera asistir «de fuera». Iniciativas como esta deberían estar a la orden del día en empresas en todo nuestro país. Desde aquí animo a cualquier colega de profesión, trabaje donde trabaje (cárnicas, startups o lo que se tercie) a que comparta lo que sabe, bien sea en un blog, dando charlas en grupos locales o imitando este tipo de iniciativas aunque sea internamente dentro de su empresa. «Hay que subir el nivel» como dice <a href="http://www.freniche.com/Inicio.html">Diego Freniche</a>. Y como me gusta repetirme a mi mismo todos los días: «si quieres cambiar las cosas, empieza cambiando tú y tu entorno».</p>
<p>La charla, que está escrita en TeX, podéis <a href="https://github.com/jespino/ponencias/tree/master/2013/kaleidos/git-internals">encontrarla en github</a>. Independientemente de los recuerdos que me trajo ver el código fuente (la tesis la escribí en LaTeX) el contenido de la misma no tiene desperdicio. Si os interesa el tema, aunque sea árido, y queréis profundizar en él os recomiendo que leáis el <a href="http://git-scm.com/book/es/Los-entesijos-internos-de-Git">capítulo 9 del libro de Scott Chacon</a>.</p>
<p>Durante la charla se habló bastante de las referencias. Cuando Jesús acabó su magistral intervención, comenté un pequeño truco que aprendí en twitter para poder descargarnos a nuestra máquina los pull requests que recibimos desde github. Llevaba tiempo queriendo sacar un rato para contarlo y Jesús me dio el empujón que me faltaba.</p>
<h1>Accediendo a los pull requests</h1>
<p>En este artículo usaremos como base el <a href="https://github.com/aprendegit/fork">repositorio</a> que utilizamos para la <a title="¿Qué es un pull request?" href="https://aprendegit.com/que-es-un-pull-request/">serie de artículos sobre pull requests</a>.</p>
<p>Cuando un usuario hace un pull request desde su fork al repositorio original, github crea en el repositorio orignal una referencia a los commits cuya incorporación se ha solicitado. El repositorio original, el que recibe el pull request, guarda estas referencias en refs/pull/*/head. Recordad que las referencias en git no son más que ficheros que contienen hashes a objetos de git. Estos ficheros están en los servidores de github.</p>
<p>Para poder acceder a esas referencias, y por lo tanto a esos commits, lo único que hay que hacer es decirle a git que se descargue los ficheros con las referencias cuando ejecutamos el comando fetch. Para ello, abrimos el fichero .git/config de nuestro repositorio y modificamos la sección correspondiente al remoto «origin», añadiendo la línea en cursiva que os pongo a continuación:</p>
<pre>[remote "origin"]
 url = https://github.com/aprendegit/fork
 fetch = +refs/heads/*:refs/remotes/origin/*
 <em><strong>fetch = +refs/pull/*/head:refs/remotes/origin/pr/*/head</strong></em></pre>
<p>Antes de ejecutar git-fetch, veamos cómo están las referencias remotas del repositorio en SourceTree:</p>
<div id="attachment_548" style="width: 282px" class="wp-caption aligncenter"><a href="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture188.png"><img loading="lazy" decoding="async" aria-describedby="caption-attachment-548" class="size-full wp-image-548" alt="Referencias remotas antes de importar los pull-requests" src="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture188.png" width="272" height="146" /></a><p id="caption-attachment-548" class="wp-caption-text">Referencias remotas antes de importar los pull-requests</p></div>
<p>Hagamos un fetch:</p>
<pre>$ git fetch
From https://github.com/aprendegit/fork
 * [new ref]         refs/pull/1/head -&gt; origin/pr/1/head
 * [new ref]         refs/pull/2/head -&gt; origin/pr/2/head
 * [new ref]         refs/pull/3/head -&gt; origin/pr/3/head</pre>
<p>¡Ahí las tenéis! Si actualizáis la pantalla de SourceTree:</p>
<div id="attachment_556" style="width: 946px" class="wp-caption aligncenter"><a href="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture190.png"><img loading="lazy" decoding="async" aria-describedby="caption-attachment-556" class="size-full wp-image-556" alt="El repositorio después de hacer fetch de los pull requests" src="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture190.png" width="936" height="474" srcset="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture190.png 936w, https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture190-300x151.png 300w, https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture190-624x316.png 624w" sizes="(max-width: 936px) 100vw, 936px" /></a><p id="caption-attachment-556" class="wp-caption-text">El repositorio después de hacer fetch de los pull requests</p></div>
<p>En la captura podéis ver los dos pull requests que ha recibido el proyecto y cómo ha evolucionado cada uno de ellos.</p>
<p>¿Y esto para qué sirve? Pues para probar el código que estáis recibiendo antes de aceptar el pull request, por ejemplo.</p>
<p>Para terminar, quería dar las gracias de nuevo a Jesús por su charla, a Kaleidos por la iniciativa y a <a href="https://github.com/piscisaureus">Bert Belder (piscisaureus)</a> por colgar el <a href="https://gist.github.com/piscisaureus/3342247">gist</a> con la información que ha dado pie a este artículo.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://aprendegit.com/uso-avanzado-de-referencias-github-y-pull-requests/feed/</wfw:commentRss>
			<slash:comments>5</slash:comments>
		
		
		<post-id xmlns="com-wordpress:feed-additions:1">544</post-id>	</item>
		<item>
		<title>git-flow: Resumen y conclusiones</title>
		<link>https://aprendegit.com/git-flow-resumen-y-conclusiones/</link>
					<comments>https://aprendegit.com/git-flow-resumen-y-conclusiones/#comments</comments>
		
		<dc:creator><![CDATA[alfonso]]></dc:creator>
		<pubDate>Mon, 15 Apr 2013 08:00:24 +0000</pubDate>
				<category><![CDATA[workflow]]></category>
		<category><![CDATA[git-flow]]></category>
		<guid isPermaLink="false">https://aprendegit.com/?p=527</guid>

					<description><![CDATA[A lo largo de las últimas semanas hemos escrito una serie de cinco artículos en los que hemos hablado sobre git-flow: En la introducción, vimos por qué surge esta extensión de git, qué hace y qué tipo de flujos de trabajo nos permite implementar. Después instalamos git-flow, creamos un repositorio e inicializamos la extensión en el mismo. [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>A lo largo de las últimas semanas hemos escrito una serie de cinco artículos en los que hemos hablado sobre git-flow:</p>
<ul>
<li><span style="line-height: 14px;">En la <a title="¿Qué es git-flow?" href="https://aprendegit.com/que-es-git-flow/">introducción</a>, vimos por qué surge esta extensión de git, qué hace y qué tipo de flujos de trabajo nos permite implementar.</span></li>
<li>Después <a title="Instalación de git-flow en linux, windows y mac" href="https://aprendegit.com/instalacion-de-git-flow/">instalamos git-flow</a>, creamos un repositorio e inicializamos la extensión en el mismo.</li>
<li>Creamos las ramas develop y master y empezamos a desarrollar las historias de usuario del sprint usando <a title="git-flow: la rama develop y uso de feature branches" href="https://aprendegit.com/git-flow-la-rama-develop-y-uso-de-feature-branches/">feature branches</a>.</li>
<li>Cuando terminamos nuestro sprint, utilizamos un <a title="git-flow: release branches" href="https://aprendegit.com/git-flow-release-branches/">release branch</a> para testar y ajustar nuestro código antes de pasarlo a producción.</li>
<li>Finalmente vimos cómo corregir bugs urgentes en producción mediante el uso de hotfix branches.</li>
</ul>
<h1> Qué nos aporta git-flow</h1>
<ul>
<li><span style="line-height: 14px;">Un flujo de trabajo básico para organizar el repositorio y nuestro trabajo.</span></li>
<li>Un convenio de nombres para nuestras ramas que permite a todos los miembros del equipo saber qué es cada cosa.</li>
<li>Unas reglas comunes a la hora de mover la información de una rama a otra.</li>
<li>Un conjunto de comandos que nos ahorra tiempo.</li>
<li>¡Sourcetree tiene soporte en la aplicación! Si has entendido cómo funciona, puedes investigar cómo usarlo en la interfaz gráfica. Tienes el botón en la barra de herramientas.</li>
</ul>
<p><a href="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture117.png"><img loading="lazy" decoding="async" class="aligncenter size-full wp-image-530" alt="Botón de git-flow en sourcetree" src="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture117.png" width="1037" height="78" srcset="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture117.png 1037w, https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture117-300x22.png 300w, https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture117-1024x77.png 1024w, https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture117-624x46.png 624w" sizes="(max-width: 1037px) 100vw, 1037px" /></a></p>
<p>A lo largo de la serie siempre hemos relacionado los comandos de git-flow con los comandos git que la extensión ejecuta por detrás. Aunque nos facilite el trabajo, el uso de git-flow no nos exime de entender cómo funcionan las ramas, saber utilizar merge y rebase o entender la diferencia entre un pull y un fetch. Es entendiendo estos conceptos como le sacarás rendimiento a esta y a cualquier otra extensión de git.</p>
<p>He utilizado este flujo de trabajo en proyectos en los que he trabajado solo y proyectos con equipos de entre 3 y 5 personas.  Mi experiencia es que esta forma de organizar el repositorio es un buen punto de partida para el desarrollo de procesos más complejos, especialmente si el equipo no tiene mucha experiencia en el uso de git.</p>
<p>Como dijimos en la introducción, estas no son reglas absolutas. Y aunque funcionan en un gran número de equipos, puede que en tu caso necesites adaptarlas a tu forma de trabajar. Confío en que después de haber leído los artículos de esta serie, estés en condiciones de hacerlo.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://aprendegit.com/git-flow-resumen-y-conclusiones/feed/</wfw:commentRss>
			<slash:comments>4</slash:comments>
		
		
		<post-id xmlns="com-wordpress:feed-additions:1">527</post-id>	</item>
		<item>
		<title>git-flow: hotfix branches</title>
		<link>https://aprendegit.com/git-flow-hotfix-branches/</link>
					<comments>https://aprendegit.com/git-flow-hotfix-branches/#comments</comments>
		
		<dc:creator><![CDATA[alfonso]]></dc:creator>
		<pubDate>Thu, 11 Apr 2013 08:00:16 +0000</pubDate>
				<category><![CDATA[workflow]]></category>
		<category><![CDATA[git-flow]]></category>
		<guid isPermaLink="false">https://aprendegit.com/?p=507</guid>

					<description><![CDATA[Seguimos hablando de git-flow. En la entrada anterior vimos cómo utilizar un release branch para poner a punto nuestra aplicación antes de llevarla a producción. En esta última entrega de la serie veremos cómo utilizar git-flow para gestionar la resolución de bugs urgentes y, en general, cualquier tipo de modificación que requiera un rápido despliegue [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>Seguimos hablando de git-flow. En la <a title="git-flow: release branches" href="https://aprendegit.com/git-flow-release-branches/">entrada anterior</a> vimos cómo utilizar un release branch para poner a punto nuestra aplicación antes de llevarla a producción. En esta última entrega de la serie veremos cómo utilizar git-flow para gestionar la resolución de bugs urgentes y, en general, cualquier tipo de modificación que requiera un rápido despliegue en producción.</p>
<h1>¿Qué son las hotfix branches de git-flow?</h1>
<p>Recordemos cómo había quedado nuestro repositorio tras la puesta en producción:</p>
<ul>
<li><span style="line-height: 14px;">La rama master, que actualmente contiene la versión 1.0, ya ha sido desplegada en producción</span></li>
<li>La rama develop, que ya incorpora todos los cambios y ajustes que hicimos durante la puesta a punto de la versión 1.0, está lista para avanzar en el desarrollo de la versión 1.1</li>
</ul>
<p>Recordemos cómo dejamos el repositorio en la entrega anterior:</p>
<p><a href="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture76.png"><img loading="lazy" decoding="async" class="aligncenter size-full wp-image-498" src="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture76.png" alt="Repositorio tras cerrar release/1.0" width="959" height="467" srcset="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture76.png 959w, https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture76-300x146.png 300w, https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture76-624x303.png 624w" sizes="(max-width: 959px) 100vw, 959px" /></a></p>
<p>Estamos listos para empezar un nuevo sprint. Tenemos una reunión de planificación, ponemos en el backlog las historias de usuario que vamos a desarrollar para la versión 1.1, y empezamos a trabajar.</p>
<p>A los pocos días, recibimos un aviso de nuestros compañeros del departamento de atención al cliente: ¡hay un bug de la aplicación en producción! Git-flow utiliza hotfix branches para implementar un flujo de trabajo que permite:</p>
<ul>
<li><span style="line-height: 1.714285714; font-size: 1rem;">Interrumpir el trabajo que estamos haciendo en la rama develop para la versión 1.1</span></li>
<li><span style="line-height: 1.714285714; font-size: 1rem;">Resolver el bug</span></li>
<li>Incorporar la corrección del bug en la rama master para desplegarlo en producción lo más rápido posible</li>
<li>Incorporar la corrección del bug en la rama develop (si procede)</li>
<li>Retomar el trabajo que estábamos haciendo en la rama develop</li>
</ul>
<p>Para los que estáis familiarizados con la administración de sistemas, a mí cada vez que me pasa esto me siento como el kernel de Linux haciendo <a href="http://es.wikipedia.org/wiki/Cambio_de_contexto">context switching</a>. Cada vez que tenemos que dejar cambiar de rama tenemos que cambiar de contexto. Eso implica recordar qué estábamos haciendo, qué teníamos en la nueva rama y en qué estado estábamos. Sin una herramienta como git, que permite hacer este cambio de forma rápida y viendo la historia de las dos ramas, el tiempo necesario para hacer el cambio de contexto nos hace menos productivos. <strong>Las ramas hotfix nos ayudan a hacer estos cambios de contexto de forma más eficiente y a corregir el problema con el mínimo impacto sobre el resto del trabajo que estamos haciendo</strong>.</p>
<h1>Creando la rama hotfix/bug-14</h1>
<p>Como hemos comentado antes, supongamos que ya llevamos unos cuantos días trabajando en el sprint. Habremos creado una (o varias) <a title="git-flow: la rama develop y uso de feature branches" href="https://aprendegit.com/git-flow-la-rama-develop-y-uso-de-feature-branches/">feature branches</a> y el estado de nuestro repositorio puede ser algo parecido a esto:</p>
<div id="attachment_512" style="width: 968px" class="wp-caption aligncenter"><a href="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture108.png"><img loading="lazy" decoding="async" aria-describedby="caption-attachment-512" class="size-full wp-image-512" src="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture108.png" alt="Estado de la rama develop antes del aviso de bug" width="958" height="465" srcset="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture108.png 958w, https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture108-300x145.png 300w, https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture108-624x302.png 624w" sizes="(max-width: 958px) 100vw, 958px" /></a><p id="caption-attachment-512" class="wp-caption-text">Estado de la rama develop antes del aviso de bug</p></div>
<p>Nos encontramos trabajando en la historia de usuario H5 cuando recibimos la llamada de nuestros compañeros avisándonos del bug.</p>
<p>Lo primero que haremos será almacenar el trabajo que estamos haciendo y que vamos a tener que interrumpir porque tenemos que cambiar de contexto. El objetivo es guardar este trabajo a medias y recuperarlo cuando hayamos terminado de corregir el bug. Hay varias formas de hacer esto, nosotros lo guardaremos en el stash ya que prevemos que la corrección del bug no nos llevará mucho tiempo:</p>
<pre>$ git stash save 'Antes de empezar a corregir el bug #14'
Saved working directory and index state On feature/h5: Antes de empezar a corregir el bug #14
HEAD is now at f6609a9 Primera implementación de las páginas estáticas</pre>
<p>Podemos ver el contenido del stash con el comando git stash list</p>
<pre>$ git stash list
stash@{0}: On feature/h5: Antes de empezar a corregir el bug #14</pre>
<p>El objetivo de esta entrada no es hablar del stash, así que entraremos en detalle en otra ocasión. Si no sabes lo que es, puedes consultar <a href="http://git-scm.com/book/es/Las-herramientas-de-Git-Guardado-r%C3%A1pido-provisional">este enlace</a>. Seguimos.</p>
<p>Una vez tenemos nuestro trabajo almacenado y listo para cambiar de contexto, creamos la rama hotfix/bug14:</p>
<pre>$ git flow hotfix start bug14
Switched to a new branch 'hotfix/bug14'

Follow-up actions:
- Bump the version number now!
- Start committing your hot fixes
- When done, run:

git flow hotfix finish 'bug14'</pre>
<div id="attachment_513" style="width: 968px" class="wp-caption aligncenter"><a href="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture109.png"><img loading="lazy" decoding="async" aria-describedby="caption-attachment-513" class="size-full wp-image-513" src="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture109.png" alt="Creando la rama hotfix/bug14" width="958" height="470" srcset="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture109.png 958w, https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture109-300x147.png 300w, https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture109-624x306.png 624w" sizes="(max-width: 958px) 100vw, 958px" /></a><p id="caption-attachment-513" class="wp-caption-text">Estado del repositorio tras crear la rama hotfix/bug14</p></div>
<p>Los comandos que git-flow ha ejecutado por nosotros son en este caso bastante sencillos:</p>
<pre>$ git checkout master
$ git checkout -b hotfix/bug14</pre>
<p>Con la rama creada, empezamos a trabajar en la corrección del bug. Pasadas unas horas y unos cuantos commits después, tenemos el bug corregido y listo para subir a producción. Este es el estado del repositorio:</p>
<div id="attachment_515" style="width: 968px" class="wp-caption aligncenter"><a href="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture110.png"><img loading="lazy" decoding="async" aria-describedby="caption-attachment-515" class="size-full wp-image-515" src="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture110.png" alt="bug #14 corregido" width="958" height="469" srcset="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture110.png 958w, https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture110-300x146.png 300w, https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture110-624x305.png 624w" sizes="(max-width: 958px) 100vw, 958px" /></a><p id="caption-attachment-515" class="wp-caption-text">Estado del repositorio después de haber localizado y corregido el bug.</p></div>
<h1>Cerrando la rama hotfix/bug14</h1>
<p>Nos acercamos al final. Una vez corregido el bug, procedemos a cerrar la rama hotfix:</p>
<pre>$ git flow hotfix finish bug14</pre>
<p>Cuando ejecutamos este comando, <strong>git-flow nos pide que introduzcamos tres mensajes:</strong></p>
<ul>
<li><span style="font-size: 1rem; line-height: 1.714285714;">El primero de ellos es el mensaje del merge commit resultado de incorporar los cambios de hotfix/bug14 en master</span></li>
</ul>
<div id="attachment_516" style="width: 805px" class="wp-caption aligncenter"><a href="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture111.png"><img loading="lazy" decoding="async" aria-describedby="caption-attachment-516" class="size-full wp-image-516" src="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture111.png" alt="Introducir mensaje para el merge commit con la rama master" width="795" height="204" srcset="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture111.png 795w, https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture111-300x76.png 300w, https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture111-624x160.png 624w" sizes="(max-width: 795px) 100vw, 795px" /></a><p id="caption-attachment-516" class="wp-caption-text">Se abre el editor predeterminado para introducir el mensaje del merge commit</p></div>
<ul>
<li><span style="line-height: 1.714285714; font-size: 1rem;">El segundo es el mensaje que git-flow pondrá a la etiqueta que va a crear para identificar esta versión (vbug14)</span></li>
</ul>
<div id="attachment_517" style="width: 809px" class="wp-caption aligncenter"><a href="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture112.png"><img loading="lazy" decoding="async" aria-describedby="caption-attachment-517" class="size-full wp-image-517" src="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture112.png" alt="Introducir mensaje para la etiqueta" width="799" height="154" srcset="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture112.png 799w, https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture112-300x57.png 300w, https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture112-624x120.png 624w" sizes="(max-width: 799px) 100vw, 799px" /></a><p id="caption-attachment-517" class="wp-caption-text">Mensaje para la etiqueta de versión</p></div>
<ul>
<li>El tercero y último será el mensaje que git-flow pondrá en el merge commit resultado de incorporar la rama hotfix/bug14 en develop</li>
</ul>
<div id="attachment_518" style="width: 808px" class="wp-caption aligncenter"><a href="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture113.png"><img loading="lazy" decoding="async" aria-describedby="caption-attachment-518" class="size-full wp-image-518" src="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture113.png" alt="Introducir mensaje para el merge commit con la rama develop" width="798" height="230" srcset="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture113.png 798w, https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture113-300x86.png 300w, https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture113-624x179.png 624w" sizes="(max-width: 798px) 100vw, 798px" /></a><p id="caption-attachment-518" class="wp-caption-text">Se abre el editor predeterminado para introducir el mensaje del merge commit con la rama develop</p></div>
<p>Al igual que cuando <a title="git-flow: release branches" href="https://aprendegit.com/git-flow-release-branches/">cerramos la rama release/1.0</a>, al finalizar la ejecución del comando se muestra un resumen de todas las acciones que han tenido lugar:</p>
<p><a href="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture115.png"><img loading="lazy" decoding="async" class="aligncenter size-full wp-image-520" src="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture115.png" alt="Salida de git-flow al cerrar un hotfix branch" width="800" height="440" srcset="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture115.png 800w, https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture115-300x165.png 300w, https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture115-624x343.png 624w" sizes="(max-width: 800px) 100vw, 800px" /></a></p>
<p>En rojo hemos indicado las acciones que git-flow ha ido ejecutando y que pueden resumirse en los siguientes comandos:</p>
<pre>git checkout master
git merge hotfix/bug14 --no-ff
git tag vbug14
git checkout develop
git merge hotfix/bug14 --no-ff
git branch -d hotfix/bug14</pre>
<p>El nombre que git-flow ha puesto a la etiqueta no es precisamente el más adecuado, así que borramos esa etiqueta y creamos una nueva que se llama v1.0.1. El repositorio queda de la siguiente manera:</p>
<p><a href="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture116.png"><img loading="lazy" decoding="async" class="aligncenter size-full wp-image-521" src="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture116.png" alt="Repositorio tras cerrar hotfix/bug14" width="959" height="466" srcset="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture116.png 959w, https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture116-300x145.png 300w, https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture116-624x303.png 624w" sizes="(max-width: 959px) 100vw, 959px" /></a></p>
<p>Y ya está, casi hemos terminado&#8230; Sólo nos falta volver a cambiar de contexto y recuperar el repositorio como lo teníamos antes de empezar a corregir el bug.</p>
<h1>Volviendo a la rama feature/h5</h1>
<p>Este paso es el más sencillo, basta ejecutar el comando</p>
<pre>$ git checkout feature/h5</pre>
<p>Ahora bien: ¿cómo recuperamos ese trabajo a medias que habíamos tenido que interrumpir y que almacenamos en el stash?</p>
<pre>$ git stash list
stash@{0}: On feature/h5: Antes de empezar a corregir el bug #14

$ git stash pop stash@{0}
Auto-merging </pre>
<p>(Nota: dado que sólo tenemos una cosa guardada en el stash, podríamos ejecutar sencillamente git stash pop).</p>
<p>Y con esto hemos terminado, ya tenemos todo listo para seguir trabajando en la historia de usuario H5.</p>
<h1>Conclusión</h1>
<p>En esta entrega hemos visto cómo git-flow nos ayuda a gestionar la corrección de bugs del sistema en producción a través de hotfix branches. Creando una rama específica para corregir el bug, conseguimos que mientras una parte del equipo está trabajando en la rama develop, otra parte pueda corregir el bug. Si es una misma persona la que tiene que hacer este trabajo, la creación de estas ramas auxiliares facilita el cambio de contexto al desarrollador.</p>
<p>Este tipo de ramas no tienen mucho sentido en las ramas develop ya que la detección y corrección de bugs forma parte del proceso de desarrollo de nueva funcionalidad</p>
<p>En la <a title="git-flow: Resumen y conclusiones" href="https://aprendegit.com/git-flow-resumen-y-conclusiones/">siguiente entrega</a> haremos un pequeño resumen de lo que hemos visto en esta serie de artículos y daremos por terminada la serie.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://aprendegit.com/git-flow-hotfix-branches/feed/</wfw:commentRss>
			<slash:comments>6</slash:comments>
		
		
		<post-id xmlns="com-wordpress:feed-additions:1">507</post-id>	</item>
		<item>
		<title>git-flow: release branches</title>
		<link>https://aprendegit.com/git-flow-release-branches/</link>
					<comments>https://aprendegit.com/git-flow-release-branches/#comments</comments>
		
		<dc:creator><![CDATA[alfonso]]></dc:creator>
		<pubDate>Tue, 02 Apr 2013 06:59:20 +0000</pubDate>
				<category><![CDATA[workflow]]></category>
		<category><![CDATA[git-flow]]></category>
		<guid isPermaLink="false">https://aprendegit.com/?p=487</guid>

					<description><![CDATA[En la entrada anterior vimos cómo utilizamos la rama develop y las features branches para desarrollar la primera versión de la aplicación. En este entrega veremos cómo utilizar las release branches  para preparar la puesta en producción de nuestra aplicación. ¿Para qué necesitamos una release branch? El objetivo de estas ramas es preparar nuestra aplicación [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>En la <a title="git-flow: la rama develop y uso de feature branches" href="https://aprendegit.com/git-flow-la-rama-develop-y-uso-de-feature-branches/">entrada anterior</a> vimos cómo utilizamos la rama develop y las features branches para desarrollar la primera versión de la aplicación. En este entrega veremos cómo utilizar las release branches  para preparar la puesta en producción de nuestra aplicación.</p>
<h1>¿Para qué necesitamos una release branch?</h1>
<p>El objetivo de estas ramas es preparar nuestra aplicación para su puesta en producción. En algunos equipos, estas ramas son las que se vuelcan en los servidores de pre-producción para hacer el testing final: se corrigen bugs, se pule la interfaz, se ajusta la maquetación&#8230;se hace la puesta a punto final de la aplicación antes de liberar la versión definitiva. Vamos a crear una release branch para la versión 1.0. Utilizando la línea de comandos, ejecutamos</p>
<pre>$ git flow release start 1.0

Switched to a new branch 'release/1.0'
Summary of actions:
- A new branch 'release/1.0' was created, based on 'develop'
- You are now on branch 'release/1.0'

Follow-up actions:

- Bump the version number now!
- Start committing last-minute fixes in preparing your release

- When done, run:

git flow release finish '1.0'</pre>
<p>Tras ejecutar estos comandos el repositorio queda de la siguiente manera:</p>
<p style="text-align: center;"><a href="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture70.png"><img loading="lazy" decoding="async" width="958" height="505" class=" wp-image-491 aligncenter" alt="Creando la rama release/1.0" src="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture70.png" srcset="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture70.png 958w, https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture70-300x158.png 300w, https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture70-624x328.png 624w" sizes="(max-width: 958px) 100vw, 958px" /></a></p>
<p>Una vez creada la rama, empezamos el proceso de corrección y depuración, que en el ejemplo que nos ocupa da como resultado varios commits a la rama release/1.0. Así queda el repositorio cuando hemos terminado de arreglar todos los bugs y estamos listos para que nuestro proyecto pase a producción:</p>
<p style="text-align: center;"><a href="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture71.png"><img loading="lazy" decoding="async" width="956" height="431" class=" wp-image-492  aligncenter" alt="Repositorio justo antes de subir a producción" src="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture71.png" srcset="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture71.png 956w, https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture71-300x135.png 300w, https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture71-624x281.png 624w" sizes="(max-width: 956px) 100vw, 956px" /></a></p>
<h1>Cerrando la rama release con git-flow</h1>
<p>En este punto, nuestro código fuente está testado, todos los bugs corregidos (o eso pensamos) y todo está listo para entregar la versión 1.0. Para cerrar la rama, ejecutamos</p>
<pre>$ git flow release finish 1.0</pre>
<p>Cuando ejecutamos este comando <strong>git-flow nos va a pedir que introduzcamos tres mensajes</strong>:</p>
<ul>
<li><span style="font-size: 1rem; line-height: 1;">El primero de ellos es el mensaje del merge commit resultado de incorporar los cambios de release/1.0 en master</span></li>
</ul>
<p style="text-align: center;"><a href="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture72.png"><img loading="lazy" decoding="async" class=" wp-image-493 aligncenter" alt="Introducir mensaje para el merge commit" src="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture72.png" width="814" height="241" srcset="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture72.png 814w, https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture72-300x88.png 300w, https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture72-624x184.png 624w" sizes="(max-width: 814px) 100vw, 814px" /></a></p>
<ul>
<li><span style="font-size: 1rem; line-height: 1.714285714;">El segundo mensaje es el mensaje que git-flow pondrá a la etiqueta que va a crear para identificar esta versión</span></li>
</ul>
<p><a style="font-size: 1rem;" href="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture73.png"><img loading="lazy" decoding="async" width="742" height="181" class="aligncenter  wp-image-494" alt="Introducir mensaje para la etiqueta" src="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture73.png" srcset="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture73.png 742w, https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture73-300x73.png 300w, https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture73-624x152.png 624w" sizes="(max-width: 742px) 100vw, 742px" /></a></p>
<ul>
<li>El tercero y último será el mensaje que git-flow pondrá en el merge commit resultado de incorporar la rama release/1.0 en develop</li>
</ul>
<p style="text-align: center;"><a href="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture74.png"><img loading="lazy" decoding="async" width="815" height="237" class=" wp-image-495 aligncenter" alt="Introducir mensaje para el merge commit con la rama develop" src="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture74.png" srcset="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture74.png 815w, https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture74-300x87.png 300w, https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture74-624x181.png 624w" sizes="(max-width: 815px) 100vw, 815px" /></a></p>
<p style="text-align: left;">Cuando el comando termina, se nos muestra un resumen de todas las acciones que han tenido lugar:</p>
<p style="text-align: left;"><a href="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture75.png"><img loading="lazy" decoding="async" class="aligncenter size-full wp-image-497" alt="Salida de git-flow al cerrar un release branch" src="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture75.png" width="816" height="765" srcset="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture75.png 816w, https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture75-300x281.png 300w, https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture75-624x585.png 624w" sizes="(max-width: 816px) 100vw, 816px" /></a>En rojo hemos indicado las acciones que git-flow ha ido ejecutando y que pueden resumirse en los siguientes comandos:</p>
<pre style="text-align: left;">git checkout master
git merge release/1.0 --no-ff
git tag v1.0
git checkout develop
git merge release/1.0 --no-ff
git branch -d release/1.0</pre>
<p style="text-align: left;">El repositorio queda de la siguiente manera:</p>
<p style="text-align: left;"><a href="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture76.png"><img loading="lazy" decoding="async" class="aligncenter size-full wp-image-498" alt="Repositorio tras cerrar release/1.0" src="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture76.png" width="959" height="467" srcset="https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture76.png 959w, https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture76-300x146.png 300w, https://aprendegit.com/wp-content/uploads/2013/04/Voila_Capture76-624x303.png 624w" sizes="(max-width: 959px) 100vw, 959px" /></a></p>
<h1 style="text-align: left;">Despliegue en producción</h1>
<p style="text-align: left;">Dado que en este ejemplo estamos trabajando con una web HTML, el despliegue en producción es muy sencillo:</p>
<ul>
<li><span style="line-height: 14px;">Sincronizamos las rama master con git push<br />
</span></li>
</ul>
<pre>git checkout master
git push</pre>
<ul>
<li><span style="line-height: 1.714285714; font-size: 1rem;">En el servidor en producción ejecutamos</span></li>
</ul>
<pre style="text-align: left;">git checkout master
git pull</pre>
<h1 style="text-align: left;">Variaciones de este flujo</h1>
<p>Cuando estamos trabajando en la rama release, puede darse el caso de que algunos bugs sean más complicados de resolver de lo esperado. Si eso ocurre, siempre podemos crear una rama dentro de release para corregir ese bug y, una vez terminado, incorporar los cambios a la rama release.</p>
<h1><span style="font-size: 1.5rem; line-height: 1.5;">Conclusión</span></h1>
<p>En esta entrega hemos visto cómo git-flow nos ayuda a gestionar la liberación de nuevas versiones de nuestro código fuente. Creando una rama específica para la puesta a punto de la versión, conseguimos <span style="line-height: 1.714285714; font-size: 1rem;">que mientras una parte del equipo está trabajando release/1.0, otra parte puede avanzar en nuevas funcionalidades usando feature branches en la rama develop.</span></p>
<p>Lo que se debe evitar es utilizar la rama release para desarrollar nuevas funcionalidades. Si esto ocurre quiere decir que hemos pasado el código a pre-producción demasiado pronto.</p>
<p>En la <a title="git-flow: hotfix branches" href="https://aprendegit.com/git-flow-hotfix-branches/">siguiente entrega</a> veremos cómo prepara hotfixes para nuestro código en producción.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://aprendegit.com/git-flow-release-branches/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
		<post-id xmlns="com-wordpress:feed-additions:1">487</post-id>	</item>
		<item>
		<title>git-flow: la rama develop y uso de feature branches</title>
		<link>https://aprendegit.com/git-flow-la-rama-develop-y-uso-de-feature-branches/</link>
					<comments>https://aprendegit.com/git-flow-la-rama-develop-y-uso-de-feature-branches/#comments</comments>
		
		<dc:creator><![CDATA[alfonso]]></dc:creator>
		<pubDate>Wed, 13 Mar 2013 13:16:43 +0000</pubDate>
				<category><![CDATA[workflow]]></category>
		<category><![CDATA[git-flow]]></category>
		<guid isPermaLink="false">https://aprendegit.com/?p=466</guid>

					<description><![CDATA[Seguimos con la serie de artículos sobre git-flow. Después de ver cómo pueden ayudarnos estas extensiones de git e instalarlas, vamos a empezar el desarrollo de nuestro proyecto utilizando git-flow. Trabajaremos con una sencilla página HTML como ejemplo. No queremos complicar la explicación ni distraernos con el código fuente; el objetivo es entender el flujo [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>Seguimos con la serie de artículos sobre git-flow. Después de ver <a title="¿Qué es git-flow?" href="https://aprendegit.com/que-es-git-flow/">cómo pueden ayudarnos</a> estas extensiones de git e <a title="Instalación de git-flow en linux, windows y mac" href="https://aprendegit.com/instalacion-de-git-flow/">instalarlas</a>, vamos a empezar el desarrollo de nuestro proyecto utilizando git-flow.</p>
<p>Trabajaremos con una sencilla página HTML como ejemplo. No queremos complicar la explicación ni distraernos con el código fuente; el objetivo es entender el flujo que vamos a implementar con git.</p>
<h1>Git-flow y metodologías ágiles</h1>
<p>Los próximos artículos vamos a escribirlos en el contexto de las <a href="http://es.wikipedia.org/wiki/Desarrollo_%C3%A1gil_de_software">metodologías ágiles</a>. Hablaremos de iteraciones, reuniones de planificación, reuniones diarias del equipo&#8230; El objetivo es poner git-flow en contexto y ver cómo nos puede ayudar.</p>
<p>Supongamos que ya hemos pasado por la reunión de planificación y hemos acordado en el equipo qué historias de usuario vamos a implementar en la primera iteración.</p>
<p>Las historias de usuario del primer sprint son las siguientes:</p>
<ul>
<li>H-1: La web dispondrá de una home con un menú de acceso al resto de páginas</li>
<li>H-2: La página de inicio dispondrá de un hero con un texto y un botón de enlace al último artículo</li>
</ul>
<p>Implementaremos la primera de las historias de forma manual y la segunda con git-flow. De esta forma entenderemos bien qué es lo que estas extensiones hacen por debajo.</p>
<h2><b>Antes de empezar: git-flow-init</b></h2>
<p>Dado que se trata de un proyecto nuevo, lo primero que haremos antes de empezar el desarrollo es, como no, crear el repositorio y prepararlo para usar git-flow. Para ello seguimos los siguientes pasos:</p>
<pre>$ mkdir nuestro-proyecto
$ cd nuestro-proyecto
$ git init
$ git-flow init

No branches exist yet. Base branches must be created now.
Branch name for production releases: [master]
Branch name for "next release" development: [develop]

How to name your supporting branch prefixes?
Feature branches? [feature/]
Release branches? [release/]
Hotfix branches? [hotfix/]
Support branches? [support/]
Version tag prefix? [] v</pre>
<p>Al ejecutar el último comando, entramos en un menú interactivo que nos va preguntando las opciones que aparecen arriba:</p>
<ul>
<li>Al inicializar git-flow, nos pregunta el nombre de la rama de producción y de la rama de desarrollo (master y develop respectivamente). Seleccionamos los nombres por defecto.</li>
<li>Después nos preguntará los prefijos que asignará a las ramas de tipo feature, release, hotfix y support. Volvemos a seleccionar los nombres por defecto.</li>
<li>Por último, nos pregunta el prefijo que queramos utilizar para etiquetar las versiones.</li>
</ul>
<p>Si no os gustan los prefijos que usa git-flow por defecto, podéis utilizar otros. En un artículo posterior veremos como cambiar a posteriori estos nombres.</p>
<p>¿Y en qué estado queda nuestro repositorio después de hacer esto? Aquí tenéis una captura de SourceTree:</p>
<div id="attachment_467" style="width: 896px" class="wp-caption aligncenter"><a href="https://aprendegit.com/wp-content/uploads/2013/03/Voila_Capture34.png"><img loading="lazy" decoding="async" aria-describedby="caption-attachment-467" class="size-full wp-image-467" alt="Estado del repositorio tras ejecutar git-flow" src="https://aprendegit.com/wp-content/uploads/2013/03/Voila_Capture34.png" width="886" height="566" srcset="https://aprendegit.com/wp-content/uploads/2013/03/Voila_Capture34.png 886w, https://aprendegit.com/wp-content/uploads/2013/03/Voila_Capture34-300x191.png 300w, https://aprendegit.com/wp-content/uploads/2013/03/Voila_Capture34-624x398.png 624w" sizes="(max-width: 886px) 100vw, 886px" /></a><p id="caption-attachment-467" class="wp-caption-text">Estado del repositorio tras ejecutar git-flow</p></div>
<p>Vemos el commit inicial así como las ramas master y develop. Desde la línea de comandos, el repositorio tiene este aspecto:</p>
<pre>$git branch -av
* develop 87ee184 Initial commit
  master  87ee184 Initial commit</pre>
<h2><b>Desarrollando H-1: gestionando las ramas manualmente</b></h2>
<p>En el proyecto, en una de las reuniones diarias, se decide que vamos a usar bootstrap para maquetar la web, así que en la primera historia descargaremos bootstrap, lo incluiremos en la carpeta vendor y crearemos la página de inicio (nota para los usuarios más avanzados: somos conscientes de que hay mejores maneras de añadir bootstrap al proyecto como por ejemplo usar submódulos. Usamos este enfoque más simple porque no queremos distraernos con detalles ajenos al objetivo de esta serie que es entender git-flow).</p>
<p>Dado que se trata de un desarrollo planificado que formará parte de un futuro release (la versión 0.1) usaremos una <a title="¿Qué es git-flow?" href="https://aprendegit.com/que-es-git-flow/">feature branch</a>.</p>
<p>Recordamos: las feature branches nacen de la rama develop y se incorporan a esa misma rama. Así que creamos una nueva rama a partir de develop que llamamos feature-H-1:</p>
<pre>$ git checkout -b feature-H-1 develop
$ git branch -av
  develop     87ee184 Initial commit
* feature-H-1 87ee184 Initial commit
  master      87ee184 Initial commit</pre>
<p>Una vez creada la rama feature-H-1, hacemos la siguiente serie de commits:</p>
<ul>
<li>Añadimos bootstrap al proyecto</li>
<li>Creamos la página de inicio</li>
<li>Ponemos el menú</li>
</ul>
<p>Cuando terminamos el desarrollo de la historia H-1, este es el estado de nuestro repositorio:</p>
<div id="attachment_470" style="width: 896px" class="wp-caption aligncenter"><a href="https://aprendegit.com/wp-content/uploads/2013/03/Voila_Capture35.png"><img loading="lazy" decoding="async" aria-describedby="caption-attachment-470" class="size-full wp-image-470" alt="Terminado el desarrollo de la historia H1" src="https://aprendegit.com/wp-content/uploads/2013/03/Voila_Capture35.png" width="886" height="566" srcset="https://aprendegit.com/wp-content/uploads/2013/03/Voila_Capture35.png 886w, https://aprendegit.com/wp-content/uploads/2013/03/Voila_Capture35-300x191.png 300w, https://aprendegit.com/wp-content/uploads/2013/03/Voila_Capture35-624x398.png 624w" sizes="(max-width: 886px) 100vw, 886px" /></a><p id="caption-attachment-470" class="wp-caption-text">Así queda el repositorio cuando terminamos de hacer el desarrollo de la historia H-1 en la rama feature-H-1</p></div>
<p>Ya hemos terminado nuestra primera historia, así que ha llegado el momento de incorporar los cambios a la rama develop (<a title="¿Qué es git-flow?" href="https://aprendegit.com/que-es-git-flow/">recuerda</a>, las feature branches se incorporan a la rama develop):</p>
<pre>$ git checkout develop
$ git merge --no-ff feature-H-1</pre>
<p>Si no sabes qué es la opción &#8211;no-ff y porqué la usamos, <a title="Forzando los merge commits" href="https://aprendegit.com/forzando-merge-commits/">lee este artículo</a>. Al ejecutar el comando se nos pide el mensaje para el merge commit:</p>
<pre>Merge branch 'feature-H-1' into develop

# Please enter a commit message to explain why this merge is necessary,
# especially if it merges an updated upstream into a topic branch.
#
# Lines starting with '#' will be ignored, and an empty message aborts
# the commit.</pre>
<p>Cuando guardamos y cerramos, este es el estado del repositorio:</p>
<div id="attachment_471" style="width: 896px" class="wp-caption aligncenter"><a href="https://aprendegit.com/wp-content/uploads/2013/03/Voila_Capture36.png"><img loading="lazy" decoding="async" aria-describedby="caption-attachment-471" class="size-full wp-image-471" alt="Repositorio después de incorporar la rama feature-H-1" src="https://aprendegit.com/wp-content/uploads/2013/03/Voila_Capture36.png" width="886" height="566" srcset="https://aprendegit.com/wp-content/uploads/2013/03/Voila_Capture36.png 886w, https://aprendegit.com/wp-content/uploads/2013/03/Voila_Capture36-300x191.png 300w, https://aprendegit.com/wp-content/uploads/2013/03/Voila_Capture36-624x398.png 624w" sizes="(max-width: 886px) 100vw, 886px" /></a><p id="caption-attachment-471" class="wp-caption-text">Estado del repositorio después de incorporar la rama feature-H-1</p></div>
<p>Como la rama feature-H-1 ha quedado visibles en el repositorio con un merge commit, podemos borrarla:</p>
<pre>$ git branch -d feature-H-1
Deleted branch feature-H-1 (was 765ce08).</pre>
<p>Pues bien, ya hemos terminado nuestra primera historia, vamos a por la segunda.</p>
<h2><b>Desarrollando H-2: gestionando las ramas con git-flow</b></h2>
<p>Para hacer esta historia, necesitaremos crear una nueva feature branch que llamaremos feature-H-2. Esta vez usaremos git-flow:</p>
<pre>$ git-flow feature start H-2
Switched to a new branch 'feature/H-2'

Summary of actions:
- A new branch 'feature/H-2' was created, based on 'develop'
- You are now on branch 'feature/H-2'

Now, start committing on your feature. When done, use:

     git flow feature finish H-2</pre>
<p>Notar que no necesitamos poner el prefijo “feature” para crear la rama, git-flow lo hace por nosotros. El propio git-flow se encarga de activar la rama feature/H-2 y de decirnos qué tenemos que hacer cuando terminemos. El estado del repositorio después de ejecutar el comando es el siguiente:</p>
<div id="attachment_473" style="width: 897px" class="wp-caption aligncenter"><a href="https://aprendegit.com/wp-content/uploads/2013/03/Voila_Capture37.png"><img loading="lazy" decoding="async" aria-describedby="caption-attachment-473" class="size-full wp-image-473" alt="Usando git-flow para crear feature/H-2" src="https://aprendegit.com/wp-content/uploads/2013/03/Voila_Capture37.png" width="887" height="565" srcset="https://aprendegit.com/wp-content/uploads/2013/03/Voila_Capture37.png 887w, https://aprendegit.com/wp-content/uploads/2013/03/Voila_Capture37-300x191.png 300w, https://aprendegit.com/wp-content/uploads/2013/03/Voila_Capture37-624x397.png 624w" sizes="(max-width: 887px) 100vw, 887px" /></a><p id="caption-attachment-473" class="wp-caption-text">Estado del repositorio después de crear la rama feature/H-2 con gitflow</p></div>
<p>Con la rama creada, nos ponermos a trabajar. Implementamos el hero de la página de inicio y hacemos los commits correspondientes:</p>
<div id="attachment_474" style="width: 973px" class="wp-caption aligncenter"><a href="https://aprendegit.com/wp-content/uploads/2013/03/Voila_Capture39.png"><img loading="lazy" decoding="async" aria-describedby="caption-attachment-474" class="size-full wp-image-474" alt="rama feature/H-2 antes de cerrarla" src="https://aprendegit.com/wp-content/uploads/2013/03/Voila_Capture39.png" width="963" height="563" srcset="https://aprendegit.com/wp-content/uploads/2013/03/Voila_Capture39.png 963w, https://aprendegit.com/wp-content/uploads/2013/03/Voila_Capture39-300x175.png 300w, https://aprendegit.com/wp-content/uploads/2013/03/Voila_Capture39-624x364.png 624w" sizes="(max-width: 963px) 100vw, 963px" /></a><p id="caption-attachment-474" class="wp-caption-text">Estado de la rama feature/H-2 una vez terminado el desarrollo</p></div>
<p>Así vemos las ramas desde la línea de comandos:</p>
<pre>$ git branch -av
  develop     b7bd517 Merge branch 'feature-H-1' into develop
* feature/H-2 4604003 Introduciendo el texto definitivo
  master      87ee184 Initial commit</pre>
<p>Si en un momento dado queréis listar las ramas de tipo feature desde la línea de comandos, basta con ejecutar git flow feature:</p>
<pre>$ git flow feature
* H-2</pre>
<p>Esto mismo es aplicable para las ramas hotfix, release y support.</p>
<p>Continuamos con el desarrollo. Revisamos y testamos nuestro código y cuando vemos que hemos terminado, utilizamos git-flow para cerrar la rama:</p>
<pre>$ git flow feature finish H-2
Switched to branch 'develop'
Merge made by the 'recursive' strategy.
  | 7 +++++++
 1 file changed, 7 insertions(+)
Deleted branch feature/H-2 (was 4604003).

Summary of actions:
- The feature branch 'feature/H-2' was merged into 'develop'
- Feature branch 'feature/H-2' has been removed
- You are now on branch 'develop'</pre>
<p>Es decir, hemos vuelto a la rama develop, se ha incorporado la rama feature/H-2 a develop y la feature branch se ha borrado. Después de ejecutar el comando, este es el resultado:</p>
<div id="attachment_475" style="width: 974px" class="wp-caption aligncenter"><a href="https://aprendegit.com/wp-content/uploads/2013/03/Voila_Capture40.png"><img loading="lazy" decoding="async" aria-describedby="caption-attachment-475" class="size-full wp-image-475" alt="Estado del repositorio tras cerrar la feature branch" src="https://aprendegit.com/wp-content/uploads/2013/03/Voila_Capture40.png" width="964" height="566" srcset="https://aprendegit.com/wp-content/uploads/2013/03/Voila_Capture40.png 964w, https://aprendegit.com/wp-content/uploads/2013/03/Voila_Capture40-300x176.png 300w, https://aprendegit.com/wp-content/uploads/2013/03/Voila_Capture40-624x366.png 624w" sizes="(max-width: 964px) 100vw, 964px" /></a><p id="caption-attachment-475" class="wp-caption-text">Estado del repositorio tras cerrar la feature branch</p></div>
<p>Si os fijáis, hemos hecho lo mismo ejecutando menos comandos.</p>
<p>En esta captura vemos cómo en este flujo de trabajo queda reflejado en la historia del repositorio de forma bastante limpia y clara, cuándo se empezó y finalizó el desarrollo de cada una de las feature branches.</p>
<p>Ahora toca prepararlo todo para hacer el release a producción, aunque eso lo haremos en la siguiente entrega.</p>
<p>Hemos subido este repositorio a nuestra cuenta de github. Podéis verlo en este enlace: <a href="https://github.com/aprendegit/articulo-sobre-gitflow">https://github.com/aprendegit/articulo-sobre-gitflow</a></p>
]]></content:encoded>
					
					<wfw:commentRss>https://aprendegit.com/git-flow-la-rama-develop-y-uso-de-feature-branches/feed/</wfw:commentRss>
			<slash:comments>15</slash:comments>
		
		
		<post-id xmlns="com-wordpress:feed-additions:1">466</post-id>	</item>
		<item>
		<title>Organizando las ramas en carpetas</title>
		<link>https://aprendegit.com/organizando-las-ramas-en-carpetas/</link>
					<comments>https://aprendegit.com/organizando-las-ramas-en-carpetas/#comments</comments>
		
		<dc:creator><![CDATA[alfonso]]></dc:creator>
		<pubDate>Mon, 11 Mar 2013 18:49:45 +0000</pubDate>
				<category><![CDATA[General]]></category>
		<category><![CDATA[ramas]]></category>
		<guid isPermaLink="false">https://aprendegit.com/?p=458</guid>

					<description><![CDATA[Si en el momento de crear una rama utilizas como nombre una ruta, como por ejemplo “mi-carpeta-de-ramas/nombre-de-rama”, verás que en la carpeta .git/refs/heads de tu repositorio se creará una subcarpeta “mi-carpeta-de-ramas”. Dentro de la misma verás el fichero “nombre-de-rama” con la referencia. Es decir, git convierte la cadena con formato de ruta que pasamos como [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>Si en el momento de crear una rama utilizas como nombre una ruta, como por ejemplo “mi-carpeta-de-ramas/nombre-de-rama”, verás que en la carpeta .git/refs/heads de tu repositorio se creará una subcarpeta “mi-carpeta-de-ramas”. Dentro de la misma verás el fichero “nombre-de-rama” con la referencia. Es decir, git convierte la cadena con formato de ruta que pasamos como argumento en una estructura real de carpetas.</p>
<p>Esta forma de crear ramas soporta subcarpetas, es decir, si creamos una rama que se llame carpeta1/carpeta2/mirama:</p>
<pre>$ git checkout -b carpeta1/carpeta2/mirama</pre>
<p>git creará el fichero .git/refs/heads/carpeta1/carpeta2/mirama con la referencia.</p>
<p>¿Y cómo muestra SourceTree las ramas creadas de esta manera?</p>
<p><img loading="lazy" decoding="async" class="aligncenter size-full wp-image-459" title="Organizando las ramas en carpetas" src="https://aprendegit.com/wp-content/uploads/2013/03/Voila_Capture38.png" alt="Organizando las ramas en carpetas" width="256" height="318" srcset="https://aprendegit.com/wp-content/uploads/2013/03/Voila_Capture38.png 256w, https://aprendegit.com/wp-content/uploads/2013/03/Voila_Capture38-241x300.png 241w" sizes="(max-width: 256px) 100vw, 256px" /></p>
<p>Esta forma de clasificar las ramas en carpetas es especialmente útil cuando trabajamos con ramas para hacer hotfixes, corregir bugs o desarrollar funcionalidades organizadas en historias de usuario.</p>
<p>Desde la interfaz de línea de comandos, así es como veríamos las ramas:</p>
<pre>$ git branch -av
   carpeta1/carpeta2/mirama 4604003 Introduciendo el texto definitivo
   develop                  b7bd517 Merge branch ‘feature-H-1’ into develop
*  feature/H-2              4604003 Introduciendo el text definitive
   master                   87ee184 Initial commit</pre>
<p>Si quisiésemos ver sólo las ramas feature, podemos usar la opción &#8211;list:</p>
<pre>$ git branch --list feature*
feature/H-2</pre>
<p>Para borrar la rama, usamos el comando git-branch con la ruta completa a la rama:</p>
<pre>$ git branch -D carpeta1/carpeta2/mirama</pre>
<p>Un truco muy sencillo que nos ayuda a organizar las ramas un poco mejor, especialmente útil si estáis usando SourceTree.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://aprendegit.com/organizando-las-ramas-en-carpetas/feed/</wfw:commentRss>
			<slash:comments>4</slash:comments>
		
		
		<post-id xmlns="com-wordpress:feed-additions:1">458</post-id>	</item>
		<item>
		<title>Instalación de git-flow en linux, windows y mac</title>
		<link>https://aprendegit.com/instalacion-de-git-flow/</link>
					<comments>https://aprendegit.com/instalacion-de-git-flow/#comments</comments>
		
		<dc:creator><![CDATA[alfonso]]></dc:creator>
		<pubDate>Mon, 04 Mar 2013 08:00:49 +0000</pubDate>
				<category><![CDATA[workflow]]></category>
		<category><![CDATA[git-flow]]></category>
		<guid isPermaLink="false">https://aprendegit.com/?p=439</guid>

					<description><![CDATA[Continuamos con la serie de artículos sobre git-flow. En la entrega anterior conocimos a Vincent Driessen y su flujo de trabajo. Hoy vamos a ver cómo instalar las extensiones en nuestra máquina. Instalación de git-flow Mac Si habéis instalado git a través de homebrew o macports, la instalación se muy sencilla: $ brew install git-flow $ port [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>Continuamos con la serie de artículos sobre git-flow. En la entrega anterior conocimos a Vincent Driessen y su flujo de trabajo. Hoy vamos a ver cómo instalar las extensiones en nuestra máquina.</p>
<h1>Instalación de git-flow</h1>
<h2>Mac</h2>
<p>Si habéis instalado git a través de homebrew o macports, la instalación se muy sencilla:</p>
<pre>$ brew install git-flow
$ port install git-flow</pre>
<p>Si tienes problemas con XCode 4.2 y Macports 2.0.4, sigue las instrucciones que se dan en la <a href="https://github.com/nvie/gitflow/wiki/Mac-OS-X">página de git-flow</a>. También es posible utilizar la instalación a través de wget usando el <a href="https://raw.github.com/nvie/gitflow/develop/contrib/gitflow-installer.sh">script de instalación</a> de Rick Osborne:</p>
<pre>wget --no-check-certificate -q -O - https://github.com/nvie/gitflow/raw/develop/contrib/gitflow-installer.sh | sudo bash</pre>
<h2>Linux</h2>
<p>git-flow tiene paquetes para distribuciones basadas en debian y Ubuntu. Utiliza el gestor de paquetes de tu distribución, busca el paquete e instálalo. En debian/Ubuntu, el paquete se llama git-flow, en fedora gitflow y en Archlinux gitflow-git.</p>
<p>Si tu distribución no tiene paquete disponible en los repositorios oficiales como ocurre con centos 5, la mejor manera de instalarlo es utilizar el <a href="https://raw.github.com/nvie/gitflow/develop/contrib/gitflow-installer.sh">script de instalación</a>:</p>
<pre>wget --no-check-certificate -q -O - https://github.com/nvie/gitflow/raw/develop/contrib/gitflow-installer.sh | sudo bash</pre>
<h2>Windows</h2>
<p>Las instalación es un poco más tediosa, aunque no es complicada. Seguiremos las instrucciones que se dan en la <a href="https://github.com/nvie/gitflow/wiki/Windows">página de git-flow</a> aunque con un poco más de detalle:</p>
<ul>
<li>En la página del paquete <a href="http://gnuwin32.sourceforge.net/packages/util-linux-ng.htm">util-linux-ng para windows</a>, nos bajamos los binarios y las dependencias</li>
</ul>
<p><span style="line-height: 24px;"><a href="http://gnuwin32.sourceforge.net/packages/util-linux-ng.htm"><img loading="lazy" decoding="async" class="aligncenter size-full wp-image-443" title=" util-linux-ng para windows" src="https://aprendegit.com/wp-content/uploads/2013/02/Voila_Capture30.png" alt=" util-linux-ng para windows" width="867" height="521" srcset="https://aprendegit.com/wp-content/uploads/2013/02/Voila_Capture30.png 867w, https://aprendegit.com/wp-content/uploads/2013/02/Voila_Capture30-300x180.png 300w, https://aprendegit.com/wp-content/uploads/2013/02/Voila_Capture30-624x374.png 624w" sizes="(max-width: 867px) 100vw, 867px" /></a></span></p>
<ul>
<li>Descomprimimos los dos ficheros descargados: util-linux-ng-[version]-bin.zip y util-linux-ng-[version]-dep.bin</li>
<li>Dentro de la carpeta “util-linux-ng-[version]-bin”, copiamos el fichero bin/getopt.exe a la carpeta C:\Program Files\Git\bin</li>
<li>Dentro de la carpeta “util-linux-ng-[version]-dep”, copiamos  el fichero bin/libintl3.dll a la carpeta C:\Program Files\Git\bin</li>
<li>Nota: en mi caso, tuve que hacer esto desde la línea de comandos lanzando un terminal de git bash como administrador de la máquina</li>
</ul>
<p><span style="line-height: 24px;"><a href="https://aprendegit.com/wp-content/uploads/2013/02/Voila_Capture31.png"><img loading="lazy" decoding="async" class="aligncenter size-full wp-image-444" title="descomprimiendo getopt.exe y libintl2.dll" src="https://aprendegit.com/wp-content/uploads/2013/02/Voila_Capture31.png" alt="descomprimiendo getopt.exe y libintl2.dll" width="801" height="601" srcset="https://aprendegit.com/wp-content/uploads/2013/02/Voila_Capture31.png 801w, https://aprendegit.com/wp-content/uploads/2013/02/Voila_Capture31-300x225.png 300w, https://aprendegit.com/wp-content/uploads/2013/02/Voila_Capture31-624x468.png 624w" sizes="(max-width: 801px) 100vw, 801px" /></a></span></p>
<ul>
<li>Una vez copiados los ficheros, se clona el repositorio <a href="git://github.com/nvie/gitflow.git">git://github.com/nvie/gitflow.git</a>. Puedes clonarlo utilizando la línea de comandos o tu cliente gráfico favorito.</li>
<li>Por último, abrimos una terminal de windows dentro del repositorio que acabamos de clonar y ejecutamos el comando contrib/msysgit-install.cmd “C:\Program Files\Git” (sustituyendo la ruta si en tu máquina la tienes en una carpeta diferente). Nota: este terminar también tuve que lanzarla como usuario administrador, mi usuario de trabajo no tiene permiso en la carpeta C:\Program Files\Git.</li>
</ul>
<p><span style="line-height: 24px;"><a href="https://aprendegit.com/wp-content/uploads/2013/02/Voila_Capture32.png"><img loading="lazy" decoding="async" class="aligncenter size-full wp-image-445" title="msysgit-install.cmd" src="https://aprendegit.com/wp-content/uploads/2013/02/Voila_Capture32.png" alt="msysgit-install.cmd" width="667" height="409" srcset="https://aprendegit.com/wp-content/uploads/2013/02/Voila_Capture32.png 667w, https://aprendegit.com/wp-content/uploads/2013/02/Voila_Capture32-300x183.png 300w, https://aprendegit.com/wp-content/uploads/2013/02/Voila_Capture32-624x382.png 624w" sizes="(max-width: 667px) 100vw, 667px" /></a></span></p>
<p>Listo, para confirmar que lo tenemos instalado, abrimos git bash, creamos una carpeta vacía y dentro inicializamos el repositorio con el siguiente comando:</p>
<p>&nbsp;</p>
<pre>$ git flow init</pre>
<p>Si todo ha ido bien, esto es lo que deberíamos observar:</p>
<p><span style="line-height: 24px;"><a href="https://aprendegit.com/wp-content/uploads/2013/02/Voila_Capture33.png"><img loading="lazy" decoding="async" class="aligncenter size-full wp-image-446" title="Comprobando la instalación" src="https://aprendegit.com/wp-content/uploads/2013/02/Voila_Capture33.png" alt="Comprobando la instalación" width="668" height="362" srcset="https://aprendegit.com/wp-content/uploads/2013/02/Voila_Capture33.png 668w, https://aprendegit.com/wp-content/uploads/2013/02/Voila_Capture33-300x162.png 300w, https://aprendegit.com/wp-content/uploads/2013/02/Voila_Capture33-624x338.png 624w" sizes="(max-width: 668px) 100vw, 668px" /></a><br />
</span></p>
]]></content:encoded>
					
					<wfw:commentRss>https://aprendegit.com/instalacion-de-git-flow/feed/</wfw:commentRss>
			<slash:comments>10</slash:comments>
		
		
		<post-id xmlns="com-wordpress:feed-additions:1">439</post-id>	</item>
		<item>
		<title>¿Qué es git-flow?</title>
		<link>https://aprendegit.com/que-es-git-flow/</link>
					<comments>https://aprendegit.com/que-es-git-flow/#comments</comments>
		
		<dc:creator><![CDATA[alfonso]]></dc:creator>
		<pubDate>Thu, 28 Feb 2013 09:00:41 +0000</pubDate>
				<category><![CDATA[workflow]]></category>
		<category><![CDATA[git-flow]]></category>
		<guid isPermaLink="false">https://aprendegit.com/?p=425</guid>

					<description><![CDATA[Empezamos una serie de artículos sobre git-flow, conjunto de extensiones de git que facilitan la gestión de ramas y flujos de trabajo. Si quieres seguir esta serie, debes disponer de una máquina con git instalado: Windows: msysgit que puedes descargar de este enlace Mac: a través de homebrew o macports Linux: a través del gestor [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>Empezamos una serie de artículos sobre git-flow, conjunto de extensiones de git que facilitan la gestión de ramas y flujos de trabajo.</p>
<p>Si quieres seguir esta serie, debes disponer de una máquina con git instalado:</p>
<ul>
<li>Windows: msysgit que puedes descargar de <a href="http://code.google.com/p/msysgit/downloads/list?q=full+installer+official+git">este enlace</a></li>
<li>Mac: a través de homebrew o macports</li>
<li>Linux: a través del gestor de paquetes de tu distribución</li>
</ul>
<h1>Flujos de trabajo</h1>
<p>Hace unos días participé en el <a href="http://www.meetup.com/madriagil/events/100800782/">Open Space de Calidad del Software</a> organizado en Madrid este mes de febrero. En la reunión se abordaron varios temas que iban desde responder a preguntas como ¿qué se calidad del software? ¿cuánto cuestan los tests funcionales? o ¿cómo hacer testing de desarrollos para dispositivos móviles? pasando por otros tan exóticos como el Pirata Roberts, llegando incluso a plantearse hasta la eliminación de los responsables de calidad de la faz de la tierra.</p>
<p>En casi todas las conversaciones en las que tuve la oportunidad de participar había un denominador común: las ramas. Se hablaba de ramas para hacer hot-fixes urgentes, ramas para desarrollar nuevas versiones separadas de las ramas maestras donde está la versión en producción. Ramas para probar nuevas versiones, ramas y repositorios para trabajar con proveedores externos, ramas para hacer pruebas en pre-producción, ramas para que los departamentos de calidad hagan sus pruebas antes de liberar nuevas versiones. Con git podemos crear ramas “como churros” y ese fin de semana tuve la oportunidad de compartir con varios colegas de profesión cómo utilizar las ramas para hacer el bien. Sin embargo, esta facilidad para crear ramas también se puede utilizar para hacer el mal y sembrar el terror. Más de una vez he visto ramas creadas sin ningún criterio, sin ningún flujo de información detrás que las sustente. Esta situación suele llevar al repositorio al caos más absoluto.</p>
<p>Para no acabar en el caos, debemos establecer unas “reglas del juego” que todo el equipo debe respetar. Aunque a grandes rasgos casi todos los proyectos pueden utilizar unas reglas de base comunes, las reglas deben ser flexibles para adaptarse a los cambios que puedan surgir en el tablero de juego; al fin y al cabo, las necesidades y particularidades de cada equipo, empresa o proyecto no son las mismas.</p>
<p>¿Y cuáles son estas reglas base comunes? En enero de 2010 <a href="http://nvie.com/about/">Vincent Driessen</a> publicó en su blog un artículo en el que compartía con la comunidad un flujo de trabajo que a él le estaba funcionando: “<a href="http://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a>”. Como él mismo cuenta en el artículo (te recomiendo encarecidamente que lo leas) Vincent propone una serie de “reglas” para organizar el trabajo del equipo.</p>
<h2>Ramas master y develop</h2>
<p>El trabajo se organiza en dos ramas principales:</p>
<ul>
<li>Rama master: cualquier commit que pongamos en esta rama debe estar preparado para subir a producción</li>
<li>Rama develop: rama en la que está el código que conformará la siguiente versión planificada del proyecto</li>
</ul>
<p>Cada vez que se incorpora código a master, tenemos una nueva versión.</p>
<p>Además de estas dos ramas, Se proponen las siguientes ramas auxiliares:</p>
<ul>
<li>Feature</li>
<li>Release</li>
<li>Hotfix</li>
</ul>
<p>Cada tipo de rama, tiene sus propias reglas, que resumimos a continuación.</p>
<h3>Feature or topic branches</h3>
<div id="attachment_429" style="width: 143px" class="wp-caption alignright"><a href="http://nvie.com/posts/a-successful-git-branching-model/"><img loading="lazy" decoding="async" aria-describedby="caption-attachment-429" class="size-full wp-image-429 " title="feature branches" src="https://aprendegit.com/wp-content/uploads/2013/02/feature_branches.png" alt="feature branches" width="133" height="352" srcset="https://aprendegit.com/wp-content/uploads/2013/02/feature_branches.png 133w, https://aprendegit.com/wp-content/uploads/2013/02/feature_branches-113x300.png 113w" sizes="(max-width: 133px) 100vw, 133px" /></a><p id="caption-attachment-429" class="wp-caption-text">fuente: nvie http://nvie.com/posts/a-successful-git-branching-model/</p></div>
<ul>
<li>Se originan a partir de la rama develop.</li>
<li>Se incorporan siempre a la rama develop.</li>
<li>Nombre: cualquiera que no sea master, develop, hotfix-* o release-*</li>
</ul>
<p>Estas ramas se utilizan para desarrollar nuevas características de la aplicación que, una vez terminadas, se incorporan a la rama develop.</p>
<h3>Release branches</h3>
<ul>
<li>Se originan a partir de la rama develop</li>
<li>Se incorporan a master y develop</li>
<li>Nombre: release-*</li>
</ul>
<p>Estas ramas se utilizan para preparar el siguiente código en producción. En estas ramas se hacen los últimos ajustes y se corrigen los últimos bugs antes de pasar el código a producción incorporándolo a la rama master.</p>
<h3>Hotfix branches<a href="http://nvie.com/posts/a-successful-git-branching-model/"><img loading="lazy" decoding="async" class="alignright" title="hotfix branches" src="https://aprendegit.com/wp-content/uploads/2013/02/hotfix-branches1.png" alt="hotfix branches" width="307" height="422" /></a></h3>
<ul>
<li>Se origina a partir de la rama master
<dl id="attachment_430" class="wp-caption alignright" style="width: 317px;">
<dt class="wp-caption-dt"></dt>
<dd class="wp-caption-dd">fuente http://nvie.com/posts/a-successful-git-branching-model/</dd>
</dl>
</li>
<li>Se incorporan a la master y develop</li>
<li>Nombre: hotfix-*</li>
</ul>
<p>Esas ramas se utilizan para corregir errores y bugs en el código en producción. Funcionan de forma parecida a las Releases Branches, siendo la principal diferencia que los hotfixes no se planifican.</p>
<h1 style="text-align: left;">¿Qué es git-flow?</h1>
<p>Si queremos implementar este flujo de trabajo, cada vez que queramos hacer algo en el código, tendremos que crear la rama que corresponda, trabajar en el código, incorporar el código donde corresponda y cerrar la rama. A lo largo de nuestra jornada de trabajo necesitaremos ejecutar varias veces al día los comandos git, merge, push y pull así como hacer checkouts de diferentes ramas, borrarlas, etc. <a href="https://github.com/nvie/gitflow">Git-flow</a> son un conjunto de extensiones que nos ahorran bastante trabajo a la hora de ejecutar todos estos comandos, simplificando la gestión de las ramas de nuestro repositorio.</p>
<h1>La flexibilidad de git&#8230;y el sentido común</h1>
<p>Las «reglas» que Vincent plantea en su blog son un ejemplo de cómo git nos permite implementar un flujo de trabajo para nuestro equipo. Estas no son reglas absolutas, bien es cierto que pueden funcionar en un gran número de proyectos, aunque no siempre será así. Por ejemplo ¿qué pasa si tenemos que mantener dos o tres versiones diferentes de una misma aplicación? digamos que tenemos que mantener la versión 1.X, la 2.X y la 3.X. El tablero de juego es diferente así que necesitaremos ampliar y adaptar estas reglas para poder seguir jugando.</p>
<p>git es una herramienta que nos permite modificar estas reglas y, lo que es más importante, irlas cambiando y adaptando a medida que el proyecto avanza y el equipo madura. Una vez más, una buena dosis de sentido común será nuestra mejor aliada para responder las preguntas que nos surjan durante el camino.</p>
<h3>Referencias:</h3>
<ul>
<li><a href="http://nvie.com/posts/a-successful-git-branching-model/">A successful branching model</a></li>
<li><a href="https://github.com/nvie/gitflow">git-flow en github</a></li>
</ul>
]]></content:encoded>
					
					<wfw:commentRss>https://aprendegit.com/que-es-git-flow/feed/</wfw:commentRss>
			<slash:comments>23</slash:comments>
		
		
		<post-id xmlns="com-wordpress:feed-additions:1">425</post-id>	</item>
	</channel>
</rss>
